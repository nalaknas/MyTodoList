"use strict";

exports.__esModule = true;
exports.default = void 0;

var _core = require("@babel/core");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class RequirementsResolver {
  constructor() {
    _defineProperty(this, "requirements", []);
  }

  static resolve(path) {
    const resolver = new RequirementsResolver();

    if (Array.isArray(path)) {
      path.forEach(p => this.resolve(p));
    } else {
      resolver.resolve(path);
    }

    return resolver.statements;
  }

  /**
   * Checks that specified node or one of its ancestors is already added
   */
  isAdded(path) {
    if (this.requirements.some(req => req.path === path)) {
      return true;
    }

    if (path.parentPath) {
      return this.isAdded(path.parentPath);
    }

    return false;
  }
  /**
   * Makes a declaration statement, finds dependencies
   * and adds all of it to the list of requirements.
   */


  resolveBinding(binding) {
    let result;
    const startPosition = binding.path.node.start;

    switch (binding.kind) {
      case 'module':
        if (binding.path.isImportSpecifier() && binding.path.parentPath.isImportDeclaration()) {
          result = _core.types.importDeclaration([binding.path.node], binding.path.parentPath.node.source);
        } else {
          result = binding.path.parentPath.node;
        }

        break;

      case 'const':
      case 'let':
      case 'var':
        {
          let decl = binding.path.node;

          if (binding.path.isVariableDeclarator() && _core.types.isSequenceExpression(binding.path.node.init)) {
            // Replace SequenceExpressions (expr1, expr2, expr3, ...) with the last one
            decl = _core.types.variableDeclarator(binding.path.node.id, binding.path.node.init.expressions[binding.path.node.init.expressions.length - 1]);
          }

          result = _core.types.variableDeclaration(binding.kind, [decl]);
          break;
        }

      default:
        result = binding.path.node;
        break;
    } // result may be newly created node that not have start/end/loc info
    // which is needed to sort statements


    result.start = startPosition;
    const req = {
      result,
      path: binding.path,
      requirements: new Set()
    };
    this.requirements.push(req);
    req.requirements = this.resolve(binding.path);
  }
  /**
   * Checks that a specified identifier has a binding and tries to resolve it
   * @return `Binding` or null if there is no binding, or it is already added, or it has useless type
   */


  resolveIdentifier(path) {
    const binding = path.scope.getBinding(path.node.name);

    if (path.isReferenced() && binding && !this.isAdded(binding.path) && // @ts-ignore binding.kind can be param
    binding.kind !== 'param') {
      this.resolveBinding(binding);
      return binding;
    }

    return null;
  }
  /**
   * Finds all identifiers in a specified path, finds all related bindings
   * and recursively calls `resolve` for each of them.
   * @return `Set` with related bindings
   */


  resolve(path) {
    const set = new Set();

    if (path.isIdentifier()) {
      const binding = this.resolveIdentifier(path);

      if (binding !== null) {
        set.add(binding.path);
      }

      return set;
    }

    path.traverse({
      Identifier: p => {
        const binding = this.resolveIdentifier(p);

        if (binding !== null) {
          set.add(binding.path);
        }
      }
    });
    return set;
  }
  /**
   * Returns sorted list of required statements
   */


  get statements() {
    const statements = [];
    let requirements = this.requirements;

    while (requirements.length > 0) {
      // On each step, we add to the result list only that statements
      // which don't have any dependencies (`zeroDeps`)
      const [zeroDeps, rest] = requirements.reduce((acc, req) => {
        if (req.requirements.size === 0) {
          acc[0].push(req);
        } else {
          acc[1].push(req);
        }

        return acc;
      }, [[], []]);

      if (zeroDeps.length === 0) {
        // That means that we are in the endless loop.
        // I don't know how it's possible, but if it's ever happened, we at least would be notified.
        throw new Error('Circular dependency');
      }

      statements.push(...zeroDeps.map(req => req.result)); // Let's remove already added statements from the requirements of the rest of the list.

      requirements = rest.map(req => {
        const reqs = new Set(req.requirements);
        zeroDeps.forEach(r => reqs.delete(r.path));
        return { ...req,
          requirements: reqs
        };
      });
    } // preserve original statements order, but reversed


    statements.sort((a, b) => {
      if (a.start && b.start) {
        return b.start - a.start;
      } else {
        return 0;
      }
    });
    return statements;
  }

}

exports.default = RequirementsResolver;
//# sourceMappingURL=RequirementsResolver.js.map