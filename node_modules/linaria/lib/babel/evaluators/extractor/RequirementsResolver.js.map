{"version":3,"sources":["../../../../src/babel/evaluators/extractor/RequirementsResolver.ts"],"names":["RequirementsResolver","resolve","path","resolver","Array","isArray","forEach","p","statements","isAdded","requirements","some","req","parentPath","resolveBinding","binding","result","startPosition","node","start","kind","isImportSpecifier","isImportDeclaration","t","importDeclaration","source","decl","isVariableDeclarator","isSequenceExpression","init","variableDeclarator","id","expressions","length","variableDeclaration","Set","push","resolveIdentifier","scope","getBinding","name","isReferenced","set","isIdentifier","add","traverse","Identifier","zeroDeps","rest","reduce","acc","size","Error","map","reqs","r","delete","sort","a","b"],"mappings":"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","sourcesContent":["/**\n * This file is used to extract statements required to evaluate dependencies.\n * Starting from the exports.__linariaPreval passed as argument to static method on class RequirementsResolver,\n * it recursively extracts paths that contains identifiers that are needed to evaluate the dependency.\n */\n\nimport { types as t } from '@babel/core';\nimport type {\n  Identifier,\n  Node,\n  Statement,\n  VariableDeclarator,\n} from '@babel/types';\nimport type { Binding, NodePath } from '@babel/traverse';\n\ntype Requirement = {\n  result: Statement;\n  path: NodePath<Node>;\n  requirements: Set<NodePath>;\n};\n\nexport default class RequirementsResolver {\n  public static resolve(path: NodePath<Node> | NodePath<Node>[]): Statement[] {\n    const resolver = new RequirementsResolver();\n    if (Array.isArray(path)) {\n      path.forEach((p) => this.resolve(p));\n    } else {\n      resolver.resolve(path);\n    }\n\n    return resolver.statements;\n  }\n\n  private requirements: Requirement[] = [];\n\n  /**\n   * Checks that specified node or one of its ancestors is already added\n   */\n  private isAdded(path: NodePath<Node>): boolean {\n    if (this.requirements.some((req) => req.path === path)) {\n      return true;\n    }\n\n    if (path.parentPath) {\n      return this.isAdded(path.parentPath);\n    }\n\n    return false;\n  }\n\n  /**\n   * Makes a declaration statement, finds dependencies\n   * and adds all of it to the list of requirements.\n   */\n  private resolveBinding(binding: Binding) {\n    let result: Statement;\n    const startPosition = binding.path.node.start;\n\n    switch (binding.kind) {\n      case 'module':\n        if (\n          binding.path.isImportSpecifier() &&\n          binding.path.parentPath.isImportDeclaration()\n        ) {\n          result = t.importDeclaration(\n            [binding.path.node],\n            binding.path.parentPath.node.source\n          );\n        } else {\n          result = binding.path.parentPath.node as Statement;\n        }\n        break;\n      case 'const':\n      case 'let':\n      case 'var': {\n        let decl = (binding.path as NodePath<VariableDeclarator>).node;\n        if (\n          binding.path.isVariableDeclarator() &&\n          t.isSequenceExpression(binding.path.node.init)\n        ) {\n          // Replace SequenceExpressions (expr1, expr2, expr3, ...) with the last one\n          decl = t.variableDeclarator(\n            binding.path.node.id,\n            binding.path.node.init.expressions[\n              binding.path.node.init.expressions.length - 1\n            ]\n          );\n        }\n\n        result = t.variableDeclaration(binding.kind, [decl]);\n        break;\n      }\n      default:\n        result = binding.path.node as Statement;\n        break;\n    }\n    // result may be newly created node that not have start/end/loc info\n    // which is needed to sort statements\n    result.start = startPosition;\n\n    const req: Requirement = {\n      result,\n      path: binding.path,\n      requirements: new Set(),\n    };\n\n    this.requirements.push(req);\n\n    req.requirements = this.resolve(binding.path);\n  }\n\n  /**\n   * Checks that a specified identifier has a binding and tries to resolve it\n   * @return `Binding` or null if there is no binding, or it is already added, or it has useless type\n   */\n  private resolveIdentifier(path: NodePath<Identifier>): Binding | null {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (\n      path.isReferenced() &&\n      binding &&\n      !this.isAdded(binding.path) &&\n      // @ts-ignore binding.kind can be param\n      binding.kind !== 'param'\n    ) {\n      this.resolveBinding(binding);\n      return binding;\n    }\n\n    return null;\n  }\n\n  /**\n   * Finds all identifiers in a specified path, finds all related bindings\n   * and recursively calls `resolve` for each of them.\n   * @return `Set` with related bindings\n   */\n  private resolve(path: NodePath<Node>): Set<NodePath> {\n    const set = new Set<NodePath>();\n    if (path.isIdentifier()) {\n      const binding = this.resolveIdentifier(path);\n      if (binding !== null) {\n        set.add(binding.path);\n      }\n\n      return set;\n    }\n\n    path.traverse({\n      Identifier: (p) => {\n        const binding = this.resolveIdentifier(p);\n        if (binding !== null) {\n          set.add(binding.path);\n        }\n      },\n    });\n\n    return set;\n  }\n\n  /**\n   * Returns sorted list of required statements\n   */\n  private get statements(): Statement[] {\n    const statements: Statement[] = [];\n    let requirements = this.requirements;\n    while (requirements.length > 0) {\n      // On each step, we add to the result list only that statements\n      // which don't have any dependencies (`zeroDeps`)\n      const [zeroDeps, rest] = requirements.reduce(\n        (acc, req) => {\n          if (req.requirements.size === 0) {\n            acc[0].push(req);\n          } else {\n            acc[1].push(req);\n          }\n\n          return acc;\n        },\n        [[], []] as [Requirement[], Requirement[]]\n      );\n\n      if (zeroDeps.length === 0) {\n        // That means that we are in the endless loop.\n        // I don't know how it's possible, but if it's ever happened, we at least would be notified.\n        throw new Error('Circular dependency');\n      }\n\n      statements.push(...zeroDeps.map((req) => req.result));\n      // Let's remove already added statements from the requirements of the rest of the list.\n      requirements = rest.map((req) => {\n        const reqs = new Set(req.requirements);\n        zeroDeps.forEach((r) => reqs.delete(r.path));\n        return {\n          ...req,\n          requirements: reqs,\n        };\n      });\n    }\n\n    // preserve original statements order, but reversed\n    statements.sort((a, b) => {\n      if (a.start && b.start) {\n        return b.start - a.start;\n      } else {\n        return 0;\n      }\n    });\n\n    return statements;\n  }\n}\n"],"file":"RequirementsResolver.js"}