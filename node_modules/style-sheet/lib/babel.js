'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var evaluateSimple = _interopDefault(require('babel-helper-evaluate-path'));
var evaluateComplex = _interopDefault(require('linaria/lib/babel/evaluate'));

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

var lib = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.declare = declare;

function declare(builder) {
  return (api, options, dirname) => {
    if (!api.assertVersion) {
      api = Object.assign(copyApiObject(api), {
        assertVersion(range) {
          throwVersionError(range, api.version);
        }

      });
    }

    return builder(api, options || {}, dirname);
  };
}

function copyApiObject(api) {
  let proto = null;

  if (typeof api.version === "string" && /^7\./.test(api.version)) {
    proto = Object.getPrototypeOf(api);

    if (proto && (!has(proto, "version") || !has(proto, "transform") || !has(proto, "template") || !has(proto, "types"))) {
      proto = null;
    }
  }

  return Object.assign({}, proto, api);
}

function has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

function throwVersionError(range, version) {
  if (typeof range === "number") {
    if (!Number.isInteger(range)) {
      throw new Error("Expected string or integer value.");
    }

    range = `^${range}.0.0-0`;
  }

  if (typeof range !== "string") {
    throw new Error("Expected string or integer value.");
  }

  const limit = Error.stackTraceLimit;

  if (typeof limit === "number" && limit < 25) {
    Error.stackTraceLimit = 25;
  }

  let err;

  if (version.slice(0, 2) === "7.") {
    err = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${version}". ` + `You'll need to update your @babel/core version.`);
  } else {
    err = new Error(`Requires Babel "${range}", but was loaded with "${version}". ` + `If you are sure you have a compatible version of @babel/core, ` + `it is likely that something in your build process is loading the ` + `wrong version. Inspect the stack trace of this error to look for ` + `the first entry that doesn't mention "@babel/core" or "babel-core" ` + `to see what is calling Babel.`);
  }

  if (typeof limit === "number") {
    Error.stackTraceLimit = limit;
  }

  throw Object.assign(err, {
    code: "BABEL_VERSION_UNSUPPORTED",
    version,
    range
  });
}
});

unwrapExports(lib);
var lib_1 = lib.declare;

var lib$1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _helperPluginUtils() {
  const data = lib;

  _helperPluginUtils = function () {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-jsx",

    manipulateOptions(opts, parserOpts) {
      if (parserOpts.plugins.some(p => (Array.isArray(p) ? p[0] : p) === "typescript")) {
        return;
      }

      parserOpts.plugins.push("jsx");
    }

  };
});

exports.default = _default;
});

var jsx = unwrapExports(lib$1);

/**
 * Created by schwarzkopfb on 15/11/17.
 */

/**
 * FNV-1a hash generation init value.
 * It's exposed, because this allows user to override it.
 *
 * @type {number}
 */
hash.BASE = 0x811c9dc5;

/**
 * Generates 32 bit FNV-1a hash from the given string.
 * As explained here: http://isthe.com/chongo/tech/comp/fnv/
 *
 * @param s {string} String to generate hash from.
 * @returns {number} The result integer hash.
 */
function hash(s) {
    var h = hash.BASE;

    for (var i = 0, l = s.length; i < l; i++) {
        h ^= s.charCodeAt(i);
        h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
    }

    return h >>> 0
}

var fnv1a = hash;

function capitalizeString(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function prefixProperty(prefixProperties, property, style) {
  if (prefixProperties.hasOwnProperty(property)) {
    var newStyle = {};
    var requiredPrefixes = prefixProperties[property];
    var capitalizedProperty = capitalizeString(property);
    var keys = Object.keys(style);
    for (var i = 0; i < keys.length; i++) {
      var styleProperty = keys[i];
      if (styleProperty === property) {
        for (var j = 0; j < requiredPrefixes.length; j++) {
          newStyle[requiredPrefixes[j] + capitalizedProperty] = style[property];
        }
      }
      newStyle[styleProperty] = style[styleProperty];
    }
    return newStyle;
  }
  return style;
}

function prefixValue(plugins, property, value, style, metaData) {
  for (var i = 0, len = plugins.length; i < len; ++i) {
    var processedValue = plugins[i](property, value, style, metaData);

    // we can stop processing if a value is returned
    // as all plugin criteria are unique
    if (processedValue) {
      return processedValue;
    }
  }
}

function addIfNew(list, value) {
  if (list.indexOf(value) === -1) {
    list.push(value);
  }
}

function addNewValuesOnly(list, values) {
  if (Array.isArray(values)) {
    for (var i = 0, len = values.length; i < len; ++i) {
      addIfNew(list, values[i]);
    }
  } else {
    addIfNew(list, values);
  }
}

function isObject(value) {
  return value instanceof Object && !Array.isArray(value);
}

function createPrefixer(_ref) {
  var prefixMap = _ref.prefixMap,
      plugins = _ref.plugins;

  return function prefix(style) {
    for (var property in style) {
      var value = style[property];

      // handle nested objects
      if (isObject(value)) {
        style[property] = prefix(value);
        // handle array values
      } else if (Array.isArray(value)) {
        var combinedValue = [];

        for (var i = 0, len = value.length; i < len; ++i) {
          var processedValue = prefixValue(plugins, property, value[i], style, prefixMap);
          addNewValuesOnly(combinedValue, processedValue || value[i]);
        }

        // only modify the value if it was touched
        // by any plugin to prevent unnecessary mutations
        if (combinedValue.length > 0) {
          style[property] = combinedValue;
        }
      } else {
        var _processedValue = prefixValue(plugins, property, value, style, prefixMap);

        // only modify the value if it was touched
        // by any plugin to prevent unnecessary mutations
        if (_processedValue) {
          style[property] = _processedValue;
        }

        style = prefixProperty(prefixMap, property, style);
      }
    }

    return style;
  };
}

var w = ["Webkit"];
var m = ["Moz"];
var ms = ["ms"];
var wm = ["Webkit", "Moz"];
var wms = ["Webkit", "ms"];
var wmms = ["Webkit", "Moz", "ms"];

var data = {
  plugins: [],
  prefixMap: { "appearance": wm, "textEmphasisPosition": w, "textEmphasis": w, "textEmphasisStyle": w, "textEmphasisColor": w, "boxDecorationBreak": w, "maskImage": w, "maskMode": w, "maskRepeat": w, "maskPosition": w, "maskClip": w, "maskOrigin": w, "maskSize": w, "maskComposite": w, "mask": w, "maskBorderSource": w, "maskBorderMode": w, "maskBorderSlice": w, "maskBorderWidth": w, "maskBorderOutset": w, "maskBorderRepeat": w, "maskBorder": w, "maskType": w, "textDecorationStyle": w, "textDecorationSkip": w, "textDecorationLine": w, "textDecorationColor": w, "userSelect": wmms, "backdropFilter": w, "fontKerning": w, "scrollSnapType": wms, "scrollSnapPointsX": wms, "scrollSnapPointsY": wms, "scrollSnapDestination": wms, "scrollSnapCoordinate": wms, "clipPath": w, "shapeImageThreshold": w, "shapeImageMargin": w, "shapeImageOutside": w, "filter": w, "hyphens": wms, "flowInto": wms, "flowFrom": wms, "breakBefore": wms, "breakAfter": wms, "breakInside": wms, "regionFragment": wms, "writingMode": wms, "textOrientation": w, "tabSize": m, "fontFeatureSettings": w, "columnCount": w, "columnFill": w, "columnGap": w, "columnRule": w, "columnRuleColor": w, "columnRuleStyle": w, "columnRuleWidth": w, "columns": w, "columnSpan": w, "columnWidth": w, "wrapFlow": ms, "wrapThrough": ms, "wrapMargin": ms, "textSizeAdjust": wms }
};

// https://developer.mozilla.org/en-US/docs/Web/CSS/background-clip#Browser_compatibility
function backgroundClip(property, value) {
  if (typeof value === 'string' && value === 'text') {
    return ['-webkit-text', 'text'];
  }
}

var prefixes = ['-webkit-', '-moz-', ''];

var values = {
  'zoom-in': true,
  'zoom-out': true,
  grab: true,
  grabbing: true
};

function cursor(property, value) {
  if (property === 'cursor' && values.hasOwnProperty(value)) {
    return prefixes.map(function (prefix) {
      return prefix + value;
    });
  }
}

var isPrefixedValue_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isPrefixedValue;
var regex = /-webkit-|-moz-|-ms-/;

function isPrefixedValue(value) {
  return typeof value === 'string' && regex.test(value);
}
module.exports = exports['default'];
});

var isPrefixedValue = unwrapExports(isPrefixedValue_1);

// http://caniuse.com/#search=cross-fade
var prefixes$1 = ['-webkit-', ''];

function crossFade(property, value) {
  if (typeof value === 'string' && !isPrefixedValue(value) && value.indexOf('cross-fade(') > -1) {
    return prefixes$1.map(function (prefix) {
      return value.replace(/cross-fade\(/g, prefix + 'cross-fade(');
    });
  }
}

// http://caniuse.com/#feat=css-filter-function
var prefixes$2 = ['-webkit-', ''];

function filter(property, value) {
  if (typeof value === 'string' && !isPrefixedValue(value) && value.indexOf('filter(') > -1) {
    return prefixes$2.map(function (prefix) {
      return value.replace(/filter\(/g, prefix + 'filter(');
    });
  }
}

var values$1 = {
  flex: ['-webkit-box', '-moz-box', '-ms-flexbox', '-webkit-flex', 'flex'],
  'inline-flex': ['-webkit-inline-box', '-moz-inline-box', '-ms-inline-flexbox', '-webkit-inline-flex', 'inline-flex']
};

function flex(property, value) {
  if (property === 'display' && values$1.hasOwnProperty(value)) {
    return values$1[value];
  }
}

var alternativeValues = {
  'space-around': 'justify',
  'space-between': 'justify',
  'flex-start': 'start',
  'flex-end': 'end',
  'wrap-reverse': 'multiple',
  wrap: 'multiple'
};

var alternativeProps = {
  alignItems: 'WebkitBoxAlign',
  justifyContent: 'WebkitBoxPack',
  flexWrap: 'WebkitBoxLines',
  flexGrow: 'WebkitBoxFlex'
};

function flexboxOld(property, value, style) {
  if (property === 'flexDirection' && typeof value === 'string') {
    if (value.indexOf('column') > -1) {
      style.WebkitBoxOrient = 'vertical';
    } else {
      style.WebkitBoxOrient = 'horizontal';
    }
    if (value.indexOf('reverse') > -1) {
      style.WebkitBoxDirection = 'reverse';
    } else {
      style.WebkitBoxDirection = 'normal';
    }
  }
  if (alternativeProps.hasOwnProperty(property)) {
    style[alternativeProps[property]] = alternativeValues[value] || value;
  }
}

var prefixes$3 = ['-webkit-', '-moz-', ''];
var values$2 = /linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient/gi;

function gradient(property, value) {
  if (typeof value === 'string' && !isPrefixedValue(value) && values$2.test(value)) {
    return prefixes$3.map(function (prefix) {
      return value.replace(values$2, function (grad) {
        return prefix + grad;
      });
    });
  }
}

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function isSimplePositionValue(value) {
  return typeof value === 'number' && !isNaN(value);
}

var alignmentValues = ['center', 'end', 'start', 'stretch'];

var displayValues = {
  'inline-grid': ['-ms-inline-grid', 'inline-grid'],
  grid: ['-ms-grid', 'grid']
};

var propertyConverters = {
  alignSelf: function alignSelf(value, style) {
    if (alignmentValues.indexOf(value) > -1) {
      style.msGridRowAlign = value;
    }
  },

  gridColumn: function gridColumn(value, style) {
    if (isSimplePositionValue(value)) {
      style.msGridColumn = value;
    } else {
      var _value$split$map = value.split('/').map(function (position) {
        return +position;
      }),
          _value$split$map2 = _slicedToArray(_value$split$map, 2),
          start = _value$split$map2[0],
          end = _value$split$map2[1];

      propertyConverters.gridColumnStart(start, style);
      propertyConverters.gridColumnEnd(end, style);
    }
  },

  gridColumnEnd: function gridColumnEnd(value, style) {
    var msGridColumn = style.msGridColumn;

    if (isSimplePositionValue(value) && isSimplePositionValue(msGridColumn)) {
      style.msGridColumnSpan = value - msGridColumn;
    }
  },

  gridColumnStart: function gridColumnStart(value, style) {
    if (isSimplePositionValue(value)) {
      style.msGridColumn = value;
    }
  },

  gridRow: function gridRow(value, style) {
    if (isSimplePositionValue(value)) {
      style.msGridRow = value;
    } else {
      var _value$split$map3 = value.split('/').map(function (position) {
        return +position;
      }),
          _value$split$map4 = _slicedToArray(_value$split$map3, 2),
          start = _value$split$map4[0],
          end = _value$split$map4[1];

      propertyConverters.gridRowStart(start, style);
      propertyConverters.gridRowEnd(end, style);
    }
  },

  gridRowEnd: function gridRowEnd(value, style) {
    var msGridRow = style.msGridRow;

    if (isSimplePositionValue(value) && isSimplePositionValue(msGridRow)) {
      style.msGridRowSpan = value - msGridRow;
    }
  },

  gridRowStart: function gridRowStart(value, style) {
    if (isSimplePositionValue(value)) {
      style.msGridRow = value;
    }
  },

  gridTemplateColumns: function gridTemplateColumns(value, style) {
    style.msGridColumns = value;
  },

  gridTemplateRows: function gridTemplateRows(value, style) {
    style.msGridRows = value;
  },

  justifySelf: function justifySelf(value, style) {
    if (alignmentValues.indexOf(value) > -1) {
      style.msGridColumnAlign = value;
    }
  }
};

function grid(property, value, style) {
  if (property === 'display' && value in displayValues) {
    return displayValues[value];
  }

  if (property in propertyConverters) {
    var propertyConverter = propertyConverters[property];
    propertyConverter(value, style);
  }
}

// http://caniuse.com/#feat=css-image-set
var prefixes$4 = ['-webkit-', ''];

function imageSet(property, value) {
  if (typeof value === 'string' && !isPrefixedValue(value) && value.indexOf('image-set(') > -1) {
    return prefixes$4.map(function (prefix) {
      return value.replace(/image-set\(/g, prefix + 'image-set(');
    });
  }
}

var alternativeProps$1 = {
  marginBlockStart: ['WebkitMarginBefore'],
  marginBlockEnd: ['WebkitMarginAfter'],
  marginInlineStart: ['WebkitMarginStart', 'MozMarginStart'],
  marginInlineEnd: ['WebkitMarginEnd', 'MozMarginEnd'],
  paddingBlockStart: ['WebkitPaddingBefore'],
  paddingBlockEnd: ['WebkitPaddingAfter'],
  paddingInlineStart: ['WebkitPaddingStart', 'MozPaddingStart'],
  paddingInlineEnd: ['WebkitPaddingEnd', 'MozPaddingEnd'],
  borderBlockStart: ['WebkitBorderBefore'],
  borderBlockStartColor: ['WebkitBorderBeforeColor'],
  borderBlockStartStyle: ['WebkitBorderBeforeStyle'],
  borderBlockStartWidth: ['WebkitBorderBeforeWidth'],
  borderBlockEnd: ['WebkitBorderAfter'],
  borderBlockEndColor: ['WebkitBorderAfterColor'],
  borderBlockEndStyle: ['WebkitBorderAfterStyle'],
  borderBlockEndWidth: ['WebkitBorderAfterWidth'],
  borderInlineStart: ['WebkitBorderStart', 'MozBorderStart'],
  borderInlineStartColor: ['WebkitBorderStartColor', 'MozBorderStartColor'],
  borderInlineStartStyle: ['WebkitBorderStartStyle', 'MozBorderStartStyle'],
  borderInlineStartWidth: ['WebkitBorderStartWidth', 'MozBorderStartWidth'],
  borderInlineEnd: ['WebkitBorderEnd', 'MozBorderEnd'],
  borderInlineEndColor: ['WebkitBorderEndColor', 'MozBorderEndColor'],
  borderInlineEndStyle: ['WebkitBorderEndStyle', 'MozBorderEndStyle'],
  borderInlineEndWidth: ['WebkitBorderEndWidth', 'MozBorderEndWidth']
};

function logical(property, value, style) {
  if (Object.prototype.hasOwnProperty.call(alternativeProps$1, property)) {
    var alternativePropList = alternativeProps$1[property];
    for (var i = 0, len = alternativePropList.length; i < len; ++i) {
      style[alternativePropList[i]] = value;
    }
  }
}

function position(property, value) {
  if (property === 'position' && value === 'sticky') {
    return ['-webkit-sticky', 'sticky'];
  }
}

var prefixes$5 = ['-webkit-', '-moz-', ''];

var properties = {
  maxHeight: true,
  maxWidth: true,
  width: true,
  height: true,
  columnWidth: true,
  minWidth: true,
  minHeight: true
};
var values$3 = {
  'min-content': true,
  'max-content': true,
  'fill-available': true,
  'fit-content': true,
  'contain-floats': true
};

function sizing(property, value) {
  if (properties.hasOwnProperty(property) && values$3.hasOwnProperty(value)) {
    return prefixes$5.map(function (prefix) {
      return prefix + value;
    });
  }
}

/* eslint-disable no-var, prefer-template */
var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache = {};

function toHyphenLower(match) {
  return '-' + match.toLowerCase()
}

function hyphenateStyleName(name) {
  if (cache.hasOwnProperty(name)) {
    return cache[name]
  }

  var hName = name.replace(uppercasePattern, toHyphenLower);
  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
}

var hyphenateStyleName$1 = /*#__PURE__*/Object.freeze({
	'default': hyphenateStyleName
});

var _hyphenateStyleName = getCjsExportFromNamespace(hyphenateStyleName$1);

var hyphenateProperty_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = hyphenateProperty;



var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function hyphenateProperty(property) {
  return (0, _hyphenateStyleName2.default)(property);
}
module.exports = exports['default'];
});

var hyphenateProperty = unwrapExports(hyphenateProperty_1);

var properties$1 = {
  transition: true,
  transitionProperty: true,
  WebkitTransition: true,
  WebkitTransitionProperty: true,
  MozTransition: true,
  MozTransitionProperty: true
};

var prefixMapping = {
  Webkit: '-webkit-',
  Moz: '-moz-',
  ms: '-ms-'
};

function prefixValue$1(value, propertyPrefixMap) {
  if (isPrefixedValue(value)) {
    return value;
  }

  // only split multi values, not cubic beziers
  var multipleValues = value.split(/,(?![^()]*(?:\([^()]*\))?\))/g);

  for (var i = 0, len = multipleValues.length; i < len; ++i) {
    var singleValue = multipleValues[i];
    var values = [singleValue];
    for (var property in propertyPrefixMap) {
      var dashCaseProperty = hyphenateProperty(property);

      if (singleValue.indexOf(dashCaseProperty) > -1 && dashCaseProperty !== 'order') {
        var prefixes = propertyPrefixMap[property];
        for (var j = 0, pLen = prefixes.length; j < pLen; ++j) {
          // join all prefixes and create a new value
          values.unshift(singleValue.replace(dashCaseProperty, prefixMapping[prefixes[j]] + dashCaseProperty));
        }
      }
    }

    multipleValues[i] = values.join(',');
  }

  return multipleValues.join(',');
}

function transition(property, value, style, propertyPrefixMap) {
  // also check for already prefixed transitions
  if (typeof value === 'string' && properties$1.hasOwnProperty(property)) {
    var outputValue = prefixValue$1(value, propertyPrefixMap);
    // if the property is already prefixed
    var webkitOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
      return !/-moz-|-ms-/.test(val);
    }).join(',');

    if (property.indexOf('Webkit') > -1) {
      return webkitOutput;
    }

    var mozOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
      return !/-webkit-|-ms-/.test(val);
    }).join(',');

    if (property.indexOf('Moz') > -1) {
      return mozOutput;
    }

    style['Webkit' + capitalizeString(property)] = webkitOutput;
    style['Moz' + capitalizeString(property)] = mozOutput;
    return outputValue;
  }
}

var plugins = [backgroundClip, crossFade, cursor, filter, flexboxOld, gradient, grid, imageSet, logical, position, sizing, transition, flex];

var prefix = createPrefixer({
  prefixMap: data.prefixMap,
  plugins: plugins
});

const unitless = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true,
};

const shortHandProperties = [
  'animation',
  'background',
  'border',
  'border-bottom',
  'border-left',
  'border-radius',
  'border-right',
  'border-top',
  'column-rule',
  'columns',
  'flex',
  'flex-flow',
  'font',
  'grid',
  'grid-area',
  'grid-column',
  'grid-row',
  'grid-template',
  'list-style',
  'margin',
  'offset',
  'outline',
  'overflow',
  'padding',
  'place-content',
  'place-items',
  'place-self',
  'text-decoration',
  'transition',
];

const i18n = {
  properties: {
    borderTopLeftRadius: 'borderTopRightRadius',
    borderTopRightRadius: 'borderTopLeftRadius',
    borderBottomLeftRadius: 'borderBottomRightRadius',
    borderBottomRightRadius: 'borderBottomLeftRadius',
    borderLeftColor: 'borderRightColor',
    borderLeftStyle: 'borderRightStyle',
    borderLeftWidth: 'borderRightWidth',
    borderRightColor: 'borderLeftColor',
    borderRightStyle: 'borderLeftStyle',
    borderRightWidth: 'borderLeftWidth',
    left: 'right',
    marginLeft: 'marginRight',
    marginRight: 'marginLeft',
    paddingLeft: 'paddingRight',
    paddingRight: 'paddingLeft',
    right: 'left',
  },
  values: {
    ltr: 'rtl',
    rtl: 'ltr',
    left: 'right',
    right: 'left',
    wResize: 'eResize',
    eResize: 'wResize',
    swResize: 'seResize',
    seResize: 'swResize',
    nwResize: 'neResize',
    neResize: 'nwResize',
  },
};

// adapted from styletron - https://raw.githubusercontent.com/styletron/styletron/c157e2a3a2592d639ae665342b2c0be8774e916b/packages/styletron-engine-atomic/src/sort-css-media-queries.js

const minMaxWidth = /(!?\(\s*min(-device-)?-width).+\(\s*max(-device)?-width/i;
const minWidth = /\(\s*min(-device)?-width/i;
const maxMinWidth = /(!?\(\s*max(-device)?-width).+\(\s*min(-device)?-width/i;
const maxWidth = /\(\s*max(-device)?-width/i;

const isMinWidth = _testQuery(minMaxWidth, maxMinWidth, minWidth);
const isMaxWidth = _testQuery(maxMinWidth, minMaxWidth, maxWidth);

const minMaxHeight = /(!?\(\s*min(-device)?-height).+\(\s*max(-device)?-height/i;
const minHeight = /\(\s*min(-device)?-height/i;
const maxMinHeight = /(!?\(\s*max(-device)?-height).+\(\s*min(-device)?-height/i;
const maxHeight = /\(\s*max(-device)?-height/i;

const isMinHeight = _testQuery(minMaxHeight, maxMinHeight, minHeight);
const isMaxHeight = _testQuery(maxMinHeight, minMaxHeight, maxHeight);

const isPrint = /print/i;
const isPrintOnly = /^print$/i;
const maxValue = Number.MAX_VALUE;

function _getQueryLength(length) {
  const matches = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/.exec(length);
  if (matches === null) {
    return maxValue
  }
  let number = matches[1];
  const unit = matches[2];
  switch (unit) {
    case 'ch':
      number = parseFloat(number) * 8.8984375;
      break
    case 'em':
    case 'rem':
      number = parseFloat(number) * 16;
      break
    case 'ex':
      number = parseFloat(number) * 8.296875;
      break
    case 'px':
      number = parseFloat(number);
      break
  }
  return +number
}

function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
  return function(query) {
    if (doubleTestTrue.test(query)) {
      return true
    } else if (doubleTestFalse.test(query)) {
      return false
    }
    return singleTest.test(query)
  }
}

function _testIsPrint(a, b) {
  const isPrintA = isPrint.test(a);
  const isPrintOnlyA = isPrintOnly.test(a);
  const isPrintB = isPrint.test(b);
  const isPrintOnlyB = isPrintOnly.test(b);

  if (isPrintA && isPrintB) {
    if (!isPrintOnlyA && isPrintOnlyB) {
      return 1
    }
    if (isPrintOnlyA && !isPrintOnlyB) {
      return -1
    }
    return a.localeCompare(b)
  }
  if (isPrintA) {
    return 1
  }
  if (isPrintB) {
    return -1
  }
  return null
}

function sortCSSmq(a, b) {
  if (a === '') {
    return -1
  }
  if (b === '') {
    return 1
  }
  const testIsPrint = _testIsPrint(a, b);
  if (testIsPrint !== null) {
    return testIsPrint
  }

  const minA = isMinWidth(a) || isMinHeight(a);
  const maxA = isMaxWidth(a) || isMaxHeight(a);
  const minB = isMinWidth(b) || isMinHeight(b);
  const maxB = isMaxWidth(b) || isMaxHeight(b);

  if (minA && maxB) {
    return -1
  }
  if (maxA && minB) {
    return 1
  }

  const lengthA = _getQueryLength(a);
  const lengthB = _getQueryLength(b);

  if (lengthA === maxValue && lengthB === maxValue) {
    return a.localeCompare(b)
  } else if (lengthA === maxValue) {
    return 1
  } else if (lengthB === maxValue) {
    return -1
  }

  if (lengthA > lengthB) {
    if (maxA) {
      return -1
    }
    return 1
  }

  if (lengthA < lengthB) {
    if (maxA) {
      return 1
    }
    return -1
  }

  return a.localeCompare(b)
}

/**
 * This module is a fork of and modifies: https://git.io/fjceH
 *
 * The original source is (c) Nicolas Gallagher
 * and licensed under the MIT license found a thttps://git.io/fjceS
 */

/**
 * Order-based insertion of CSS.
 *
 * Each rule is associated with a numerically defined group.
 * Groups are ordered within the style sheet according to their number, with the
 * lowest first.
 *
 * Groups are implemented using marker rules. The selector of the first rule of
 * each group is used only to encode the group number for hydration. An
 * alternative implementation could rely on CSSMediaRule, allowing groups to be
 * treated as a sub-sheet, but the Edge implementation of CSSMediaRule is
 * broken.
 * https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule
 * https://gist.github.com/necolas/aa0c37846ad6bd3b05b727b959e82674
 */
function createOrderedCSSStyleSheet(sheet) {
  let groups = {};
  let selectors = {};

  /**
   * Hydrate approximate record from any existing rules in the sheet.
   */
  if (sheet != null) {
    let group;
    Array.prototype.forEach.call(sheet.cssRules, function(cssRule, i) {
      const cssText = cssRule.cssText;
      // Create record of existing selectors and rules
      if (cssText.indexOf('style-sheet-group') > -1) {
        group = decodeGroupRule(cssRule);
        groups[group] = { start: i, rules: [cssText], mq: [] };
      } else {
        const selectorText = getSelectorText(cssText);
        if (selectorText != null) {
          selectors[selectorText.selector] = true;
          let index = groups[group].rules.length - 1;
          if (selectorText.media) {
            index = groups[group].mq.indexOf(selectorText.media);
            if (index === -1) {
              groups[group].mq.push(selectorText.media);
              groups[group].mq.sort(sortCSSmq);
              index = groups[group].mq.indexOf(selectorText.media);
            }
          }
          groups[group].rules.splice(index + 1, 0, cssText);
        }
      }
    });
  }

  function sheetInsert(sheet, group, text, index) {
    const orderedGroups = getOrderedGroups(groups);
    const groupIndex = orderedGroups.indexOf(group);
    const nextGroupIndex = groupIndex + 1;
    const nextGroup = orderedGroups[nextGroupIndex];
    // Insert rule before the next group, or at the end of the stylesheet
    const position =
      nextGroup != null && groups[nextGroup].start != null
        ? groups[nextGroup].start - typeof index === 'number'
          ? groups[group].rules.length - index
          : 0
        : sheet.cssRules.length;
    const isInserted = insertRuleAt(sheet, text, position);

    if (isInserted) {
      // Set the starting index of the new group
      if (groups[group].start == null) {
        groups[group].start = position;
      }
      // Increment the starting index of all subsequent groups
      for (let i = nextGroupIndex; i < orderedGroups.length; i += 1) {
        const groupNumber = orderedGroups[i];
        const previousStart = groups[groupNumber].start;
        groups[groupNumber].start = previousStart + 1;
      }
    }

    return isInserted
  }

  function getTextContent() {
    return getOrderedGroups(groups).reduce(function(text, group, index) {
      const rules = groups[group].rules;
      return text + (index > 0 ? '\n' : '') + rules.join('\n')
    }, '')
  }

  const OrderedCSSStyleSheet = {
    /**
     * The textContent of the style sheet.
     */
    getTextContent,

    /**
     * Returns the textContent of the style sheet and removes all the rules from it.
     */
    flush() {
      const textContent = getTextContent();
      groups = {};
      selectors = {};
      if (sheet != null) {
        Array.prototype.forEach.call(sheet.cssRules, function(_, i) {
          sheet.deleteRule(i);
        });
      }
      return textContent
    },

    /**
     * Insert a rule into the style sheet
     */
    insertRule(cssText, groupValue, index) {
      const group = Number(groupValue);

      if (isNaN(group)) {
        throw new Error(
          `${groupValue} - Invalid group. Use OrderedCSSStyleSheet.insertRule(cssText, groupId)`
        )
      }

      // Create a new group.
      if (groups[group] == null) {
        const markerRule = encodeGroupRule(group);
        // Create the internal record.
        groups[group] = { start: null, rules: [markerRule], mq: [] };
        // Update CSSOM.
        if (sheet != null) {
          sheetInsert(sheet, group, markerRule);
        }
      }

      // selectorText is more reliable than cssText for insertion checks. The
      // browser excludes vendor-prefixed properties and rewrites certain values
      // making cssText more likely to be different from what was inserted.
      const selectorText = getSelectorText(cssText);
      if (selectorText != null && selectors[selectorText.selector] == null) {
        selectors[selectorText.selector] = true;
        if (typeof index !== 'number') {
          index = groups[group].rules.length - 1;
          if (selectorText.media) {
            index = groups[group].mq.indexOf(selectorText.media);
            if (index === -1) {
              groups[group].mq.push(selectorText.media);
              groups[group].mq.sort(sortCSSmq);
              index = groups[group].mq.indexOf(selectorText.media);
            }
          }
        }
        if (index > groups[group].rules.length - 1) {
          throw new Error(`index ${index} out of bound for group ${group}`)
        }
        groups[group].rules.splice(index + 1, 0, cssText);

        // Update CSSOM.
        if (sheet != null) {
          const isInserted = sheetInsert(sheet, group, cssText, index);
          if (!isInserted) {
            // Revert internal record change if a rule was rejected (e.g.,
            // unrecognized pseudo-selector)
            groups[group].rules.splice(index + 1, 1);
          }
        }
      }
    },
  };

  return OrderedCSSStyleSheet
}

/**
 * Helper functions
 */

function encodeGroupRule(group) {
  return `[style-sheet-group="${group}"]{}`
}

function decodeGroupRule(cssRule) {
  return Number(cssRule.selectorText.split(/["']/)[1])
}

function getOrderedGroups(obj) {
  return Object.keys(obj)
    .map(Number)
    .sort((a, b) => (a > b ? 1 : -1))
}

const pattern = /\s*([,])\s*/g;
function getSelectorText(cssText) {
  const split = cssText.split('{');
  let selector = split[0].trim();
  let media = null;
  if (selector.startsWith('@media')) {
    media = selector.substring(6).trim();
    selector = split[1].trim();
  }
  return selector !== ''
    ? { media, selector: selector.replace(pattern, '$1') }
    : null
}

function insertRuleAt(root, cssText, position) {
  try {
    root.insertRule(cssText, position);
    return true
  } catch (e) {
    // JSDOM doesn't support `CSSSMediaRule#insertRule`.
    // Also ignore errors that occur from attempting to insert vendor-prefixed selectors.
    return false
  }
}

const STYLE_GROUPS = [
  'classic',
  'mediaClassic',

  'shorthand',
  'mediaShorthand',

  'shorthandCombinator',
  'mediaShorthandCombinator',

  'i18nShorthand',
  'mediaI18nShorthand',

  'i18nShorthandCombinator',
  'mediaI18nShorthandCombinator',

  'atomic',
  'mediaAtomic',

  'atomicCombinator',
  'mediaAtomicCombinator',
].reduce((groups, name, index) => {
  groups[name] = index;
  return groups
}, {});

// Fork of https://github.com/jxnblk/object-style

function createClassName(property, value, descendants, media) {
  const ruleType = getRuleType(property, media, descendants);
  return `dss${ruleType}_${fnv1a(property + descendants + media).toString(
    36
  )}-${fnv1a(String(value)).toString(36)}`
}

const hyphenate = s => s.replace(/[A-Z]|^ms/g, '-$&').toLowerCase();
const strigifyDeclaration = dec => {
  let stringified = '';

  for (const prop in dec) {
    const value = dec[prop];
    if (Array.isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        stringified += hyphenate(prop) + ':' + value[i] + ';';
      }
    } else {
      stringified += hyphenate(prop) + ':' + value + ';';
    }
  }
  return stringified
};
function createRule(className, declaration, descendants, media) {
  const cls = '.' + className.replace('.', '\\.');
  const selector = descendants
    ? descendants.replace(/^&/, cls).replace(/&/g, cls)
    : cls;
  const rule = selector + '{' + strigifyDeclaration(declaration) + '}';
  if (!media) return rule
  return media + '{' + rule + '}'
}

const order = {
  pseudo: [
    'link',
    'visited',
    'hover',
    'focus-within',
    'focus-visible',
    'focus',
    'active',
  ],
};

function getRuleType(prop, media, descendants) {
  let name = '';
  if (shortHandProperties.indexOf(prop) > -1) {
    name = media ? 'mediaShorthand' : 'shorthand';
  } else {
    name = media ? 'mediaAtomic' : 'atomic';
  }
  let subGroup = 0;
  if (descendants) {
    let subGroupPart;
    // is a combinator selector eg :hover > &
    if (descendants.substr(0, 2) !== '&:') {
      name += 'Combinator';
      subGroupPart = descendants.slice(1).split(/\s*[+>~]\s*/g)[0];
    } else {
      subGroupPart = descendants.slice(2);
    }
    const index = order.pseudo.indexOf(subGroupPart.split(':').slice(-1)[0]);
    if (index > -1) {
      subGroup = index + 1;
    }
  }

  return subGroup > 0 ? STYLE_GROUPS[name] + '.' + subGroup : STYLE_GROUPS[name]
}

function normalizeValue(value) {
  if (typeof value === 'number') {
    if (value !== 0) {
      return value + 'px'
    }
  } else if (Array.isArray(value)) {
    return value.map(v => {
      if (typeof v === 'number' && v !== 0) {
        return v + 'px'
      }
      return v
    })
  }

  return value
}

function toI18n(lookup, thing) {
  return Object.prototype.hasOwnProperty.call(lookup, thing)
    ? lookup[thing]
    : null
}

const cache$1 = {};
const parse = (obj, descendants, media, opts) => {
  const rules = {};

  for (let key in obj) {
    let value = obj[key];
    if (value === null || value === undefined) continue
    switch (Object.prototype.toString.call(value)) {
      case '[object Object]': {
        const parsed =
          key.charAt(0) === '@'
            ? parse(value, descendants, key, opts)
            : parse(value, descendants + key, media, opts);
        Object.assign(rules, parsed);
        break
      }
      default: {
        const cacheKey = key + value + descendants + media;
        const cached = cache$1[cacheKey];
        if (cached) {
          Object.assign(rules, cached);
          break
        }
        let className = createClassName(key, value, descendants, media);
        if (rules[className]) {
          break
        }
        if (!unitless[key]) {
          value = normalizeValue(value);
        }
        const declaration = prefix({ [key]: value });
        let rule = createRule(className, declaration, descendants, media);

        if (opts.i18n) {
          const originalProp = key;
          const originalValue = value;
          key = toI18n(i18n.properties, originalProp);
          value = toI18n(i18n.values, originalValue);
          if (key !== null || value !== null) {
            key = key || originalProp;
            value = value || originalValue;
            const i18nClassName = createClassName(
              key,
              value,
              descendants,
              media
            );
            // i18n classNames contain both the ltr and rtl version
            // this is resolved at runtime by the StyleResolver
            className = `${className}|${i18nClassName}`;

            const declaration = prefix({ [key]: value });
            // i18n rule is an array with two rules the ltr and the rtl one
            // eg. ['.left { margin-left: 10px }', '.right { margin-right: 10px }']
            // At runtime the StyleResolver will pick the correct one.
            rule = [
              rule,
              createRule(i18nClassName, declaration, descendants, media),
            ];
          }
        }
        rules[className] = rule;
        cache$1[cacheKey] = { [className]: rule };
        break
      }
    }
  }

  return rules
};

var compile = (obj, opts) => {
  if (!obj) {
    throw new Error('DSS parser invoked without a mandatory styles object.')
  }
  return parse(obj, '', '', opts)
};

function error(message) {
  throw new Error(`style-sheet: ${message}`)
}

function validate(obj) {
  for (const k in obj) {
    const key = k.trim();
    const value = obj[key];
    if (value === null) continue
    const isDeclaration =
      Object.prototype.toString.call(value) !== '[object Object]';
    validateStr(key, isDeclaration);
    if (!isDeclaration) {
      validate(value);
    } else if (typeof value === 'string' && /!\s*important/.test(value)) {
      error('!important is not allowed');
    }
  }
}

function validateStr(key, isDeclaration) {
  if (isDeclaration) {
    return
  }

  if (key.charAt(0) === '@') {
    return
  }

  // Selector

  if (key.split(',').length > 1) {
    error(`Invalid nested selector: '${key}'. Selectors cannot be grouped.`);
  }

  if (/::?(after|before|first-letter|first-line)/.test(key)) {
    error(
      `Detected pseudo-element: '${key}'. Pseudo-elements are not supported. Please use regular elements.`
    );
  }

  if (/:(matches|has|not|lang|any|current)/.test(key)) {
    error(`Detected unsupported pseudo-class: '${key}'.`);
  }

  const split = key.split(/\s*[+>~]\s*/g);

  switch (split.length) {
    case 2:
      if (split[0].charAt(0) !== ':') {
        error(
          `Invalid nested selector: '${key}'. ` +
            'The left part of a combinator selector must be a pseudo-class eg. `:hover`.'
        );
      }
      if (split[1] !== '&') {
        error(
          `Invalid nested selector: '${key}'. ` +
            'The right part of a combinator selector must be `&`.'
        );
      }
      break
    case 1:
      if (split[0].indexOf(' ') > -1) {
        error(
          `Invalid nested selector: ${key}. Complex selectors are not supported.`
        );
      }
      if (split[0].charAt(0) !== '&') {
        error(
          `Invalid nested selector: '${key}'. ` +
            'A pseudo-class selector should reference its parent with `&` eg. `&:hover {}`.'
        );
      }
      break
    default:
      error(`Invalid nested selector: ${key}.`);
  }

  if (/\[/.test(key)) {
    error(
      `Invalid selector: ${key}. Cannot use attribute selectors, please use only class selectors.`
    );
  }
}

var stackframe = createCommonjsModule(function (module, exports) {
(function(root, factory) {
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    {
        module.exports = factory();
    }
}(commonjsGlobal, function() {
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps);

    function StackFrame(obj) {
        if (obj instanceof Object) {
            for (var i = 0; i < props.length; i++) {
                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {
                    this['set' + _capitalize(props[i])](obj[props[i]]);
                }
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var fileName = this.getFileName() || '';
            var lineNumber = this.getLineNumber() || '';
            var columnNumber = this.getColumnNumber() || '';
            var functionName = this.getFunctionName() || '';
            if (this.getIsEval()) {
                if (fileName) {
                    return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
                }
                return '[eval]:' + lineNumber + ':' + columnNumber;
            }
            if (functionName) {
                return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
            }
            return fileName + ':' + lineNumber + ':' + columnNumber;
        }
    };

    StackFrame.fromString = function StackFrame$$fromString(str) {
        var argsStartIndex = str.indexOf('(');
        var argsEndIndex = str.lastIndexOf(')');

        var functionName = str.substring(0, argsStartIndex);
        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
        var locationString = str.substring(argsEndIndex + 1);

        if (locationString.indexOf('@') === 0) {
            var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
            var fileName = parts[1];
            var lineNumber = parts[2];
            var columnNumber = parts[3];
        }

        return new StackFrame({
            functionName: functionName,
            args: args || undefined,
            fileName: fileName,
            lineNumber: lineNumber || undefined,
            columnNumber: columnNumber || undefined
        });
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));
});

var errorStackParser = createCommonjsModule(function (module, exports) {
(function(root, factory) {
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    {
        module.exports = factory(stackframe);
    }
}(commonjsGlobal, function ErrorStackParser(StackFrame) {

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return filtered.map(function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, '');
                }
                var sanitizedLine = line.replace(/^\s+/, '').replace(/\(eval code/g, '(');

                // capture and preseve the parenthesized location "(/foo/my bar.js:12:87)" in
                // case it has spaces in it, as the string is split on \s+ later on
                var location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/);

                // remove the parenthesized location from the line, if it was matched
                sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;

                var tokens = sanitizedLine.split(/\s+/).slice(1);
                // if a location was matched, pass it to extractLocation() otherwise pop the last token
                var locationParts = this.extractLocation(location ? location[1] : tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame({
                    functionName: functionName,
                    fileName: fileName,
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return filtered.map(function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame({
                        functionName: line
                    });
                } else {
                    var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
                    var matches = line.match(functionNameRegex);
                    var functionName = matches && matches[1] ? matches[1] : undefined;
                    var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));

                    return new StackFrame({
                        functionName: functionName,
                        fileName: locationParts[0],
                        lineNumber: locationParts[1],
                        columnNumber: locationParts[2],
                        source: line
                    });
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame({
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                    }));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame({
                            functionName: match[3] || undefined,
                            fileName: match[2],
                            lineNumber: match[1],
                            source: lines[i]
                        })
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return filtered.map(function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                        .replace(/<anonymous function(: (\w+))?>/, '$2')
                        .replace(/\([^\)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^\)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');

                return new StackFrame({
                    functionName: functionName,
                    args: args,
                    fileName: locationParts[0],
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        }
    };
}));
});

/* global Blob, Worker, URL, module */

function createSourceMapsEngine({
  baseUrl = 'https://unpkg.com/css-to-js-sourcemap-worker@2.0.5',
  renderInterval = 120,
} = {}) {
  const workerBlob = new Blob([`importScripts("${baseUrl}/worker.js")`], {
    type: 'application/javascript',
  });
  let worker = new Worker(URL.createObjectURL(workerBlob));
  worker.postMessage({
    id: 'init_wasm',
    url: `${baseUrl}/mappings.wasm`,
  });
  const style = document.createElement('style');
  document.head.appendChild(style);
  worker.postMessage({
    id: 'set_render_interval',
    interval: renderInterval,
  });
  if (module && module.hot) {
    module.hot.addStatusHandler(status => {
      if (status === 'dispose') {
        worker.postMessage({ id: 'invalidate' });
      }
    });
  }

  worker.onmessage = msg => {
    const { id, css } = msg.data;
    if (id === 'render_css' && css) {
      style.appendChild(document.createTextNode(css));
    }
  };

  let counter = 0;
  return {
    create(className = `__debug`) {
      const stackIndex = 3;
      const error = new Error('stacktrace source');
      const prefix = getDebugClassName(error, stackIndex);
      const cls =
        typeof className === 'function'
          ? className(prefix, counter)
          : className + '-' + counter;
      counter++;
      worker.postMessage({
        id: 'add_mapped_class',
        className: cls,
        stackInfo: {
          stack: error.stack,
          message: error.message,
        },
        stackIndex,
      });
      return cls
    },
  }
}

function getDebugClassName(error, stackIndex = 1) {
  const line = errorStackParser.parse(error)[stackIndex];
  if (!line || !line.fileName) {
    return '__dss-debug'
  }
  const parts = line.fileName.split('/');
  let name = parts.pop().replace(/\..*$/, '');
  if (name === 'index') {
    name = parts.pop();
  }
  name = name.replace(/\W/g, '-');
  return name.charAt(0).toUpperCase() + name.slice(1)
}

const isBrowser = typeof window !== 'undefined';
const isProd = process.env.NODE_ENV === 'production';
const isTest = process.env.NODE_ENV === 'test';

function createStyleSheet(rules, opts) {
  const cache = typeof Map === 'undefined' ? null : new Map();
  let sourceMapsEngine;
  if (!isProd && !isTest && !isBrowser && typeof Worker !== 'undefined') {
    sourceMapsEngine = createSourceMapsEngine();
  }

  return {
    create: styles => {
      if (cache) {
        const cached = cache.get(styles);
        if (cached) {
          return cached
        }
      }
      const locals = {};

      for (const token in styles) {
        const rule = styles[token];
        if (!isProd) {
          validate(rule);
        }
        const compiled = compile(rule, opts);
        Object.assign(rules, compiled);

        locals[token] = Object.keys(compiled);

        // In dev add source maps
        if (!isProd && sourceMapsEngine) {
          locals[token].unshift(
            sourceMapsEngine.create((prefix, id) =>
              opts.sourceMaps.className({ prefix, key: token, id })
            )
          );
        }
      }

      if (cache) {
        cache.set(styles, locals);
      }

      return locals
    },
  }
}

function concatClassName(dest, className) {
  if (className.substr(0, 3) !== 'dss') {
    return {
      shouldInject: false,
      className: `${className} ${dest}`,
      group: null,
    }
  }
  const property = className.substr(0, className.indexOf('-'));
  if (dest.indexOf(property) > -1) {
    return { shouldInject: false, className: dest, group: null }
  }
  return {
    shouldInject: true,
    className: `${dest} ${className}`,
    group: Number(
      className.substring(3, className.indexOf('_')).replace('\\', '')
    ),
  }
}

function createStyleResolver(sheet, rules, opts) {
  let resolved = {};
  let injected = {};

  return {
    getStyleSheet() {
      // On the server we reset the caches.
      if (typeof window === 'undefined') {
        resolved = {};
        injected = {};
      }
      return sheet
    },
    resolve(style) {
      const i18n = opts.i18n || {};
      const stylesToString =
        i18n.isRTL + i18n.doLeftAndRightSwapInRTL + style.join();

      if (resolved[stylesToString]) {
        return resolved[stylesToString]
      }

      let resolvedClassName = '';

      for (let i = style.length - 1; i >= 0; i--) {
        let current = style[i];
        if (!current) {
          continue
        }
        if (typeof current === 'string') {
          current = [current];
        }
        for (let j = 0; j < current.length; j++) {
          let className = current[j];
          let rule;

          // resolve i18n rules
          const i18nClassNames = className.split('|');
          let i18nRules;
          let i18nIndex;
          if (i18nClassNames.length > 1) {
            if (i18n.isRTL && i18n.doLeftAndRightSwapInRTL) {
              i18nIndex = 1;
            } else {
              i18nIndex = 0;
            }
            i18nRules = rules[className];
            className = i18nClassNames[i18nIndex];
            rule = i18nRules[i18nIndex];
          } else {
            rule = rules[className];
          }

          const result = concatClassName(resolvedClassName, className);
          resolvedClassName = result.className;

          if (result.shouldInject && !injected[className]) {
            if (rule) {
              sheet.insertRule(rule, result.group);
              if (i18nRules && !isBrowser) {
                const i18nIndexInverse = i18nIndex ? 0 : 1;
                sheet.insertRule(i18nRules[i18nIndexInverse], result.group);
                injected[i18nClassNames[i18nIndexInverse]] = true;
              }
            }
            injected[className] = true;
          }
        }
      }

      resolvedClassName = resolvedClassName.trim();
      resolved[stylesToString] = resolvedClassName;
      return resolvedClassName
    },
  }
}

function createSheet(document) {
  document = document || typeof window === 'undefined' ? null : window.document;
  let sheet = null;

  if (document) {
    const style = document.createElement('style');
    document.head.appendChild(style);
    sheet = style.sheet;
  }

  return sheet
}

function create(options = {}) {
  let i18n;
  function setI18nManager(manager) {
    i18n = manager;
    if (i18n && !isProd) {
      if (typeof i18n.isRTL !== 'boolean') {
        throw new Error('i18n.isRTL must be a boolean.')
      }
      if (typeof i18n.doLeftAndRightSwapInRTL !== 'boolean') {
        throw new Error('i18n.doLeftAndRightSwapInRTL must be a boolean.')
      }
    }
  }
  setI18nManager(options.i18n);

  const sheet = createOrderedCSSStyleSheet(options.sheet || createSheet());
  const rules = {};

  const opts = {
    get i18n() {
      return i18n
    },
  };

  if (!isProd) {
    opts.sourceMaps = Object.assign(
      {
        className: ({ prefix, key, id }) => `${prefix}__${key}-${id}`,
      },
      options.sourceMaps || {}
    );
  }

  return {
    StyleSheet: createStyleSheet(rules, opts),
    StyleResolver: createStyleResolver(sheet, rules, opts),
    setI18nManager,
  }
}

const { StyleSheet, StyleResolver, setI18nManager } = create();

// This function returns the extracted CSS to save in a .css file.
// It must be called after all the files are processed by Babel.
function getCss() {
  return StyleResolver.getStyleSheet().flush()
}

function babel(babel) {
  let setI18n = false;
  return {
    name: 'style-sheet/babel',
    inherits: jsx,
    visitor: {
      Program: {
        enter(path, state) {
          if (!setI18n && typeof state.opts.rtl === 'boolean') {
            setI18n = true;
            setI18nManager({
              isRTL: state.opts.rtl,
              doLeftAndRightSwapInRTL: state.opts.rtl,
            });
          }
        },
        exit(path, state) {
          const { types: t } = babel;
          if (!state.hasStyleSheetImport && state.needsStyleSheetImport) {
            const importSpecifier = t.identifier(
              state.opts.importName || 'StyleSheet'
            );
            const importDeclaration = t.importDeclaration(
              [t.importSpecifier(importSpecifier, importSpecifier)],
              t.stringLiteral(state.opts.packageName || 'style-sheet')
            );
            path.node.body.unshift(importDeclaration);
          }
          if (!state.hasStylePropImport && state.needsStylePropImport) {
            const importSpecifier = t.identifier('createElement');
            const importDeclaration = t.importDeclaration(
              [t.importSpecifier(importSpecifier, importSpecifier)],
              t.stringLiteral(state.opts.stylePropPackageName)
            );
            path.node.body.unshift(importDeclaration);
          }
        },
      },
      JSXAttribute(path, state) {
        if (!state.opts.stylePropName) {
          state.opts.stylePropName = 'css';
        }
        if (path.node.name.name !== state.opts.stylePropName) {
          return
        }

        const value = path.get('value');
        if (!value.isJSXExpressionContainer()) {
          return
        }

        let expression = value.get('expression');

        const { types: t } = babel;
        const cloneNode = t.cloneNode || t.cloneDeep;
        const importName = state.opts.importName || 'StyleSheet';

        let isExpressionArray = false;
        let expressions;
        if (expression.isArrayExpression()) {
          isExpressionArray = true;
          expressions = expression.get('elements');
        } else {
          expressions = [expression];
        }

        const hoisted = expressions
          .map(expression => {
            if (!expression.isPure()) {
              return
            }

            const replacement = t.callExpression(
              t.memberExpression(
                t.identifier(importName),
                t.identifier('create')
              ),
              [
                t.objectExpression([
                  t.objectProperty(
                    t.identifier('__styleProp'),
                    cloneNode(expression.node)
                  ),
                ]),
              ]
            );
            expression.replaceWith(replacement);
            processReferencePath(babel, expression, state);
            return expression.hoist()
          })
          .filter(Boolean);

        if (isExpressionArray && hoisted.length === expressions.length) {
          expression.hoist();
        }

        state.needsStylePropImport = true;

        if (!state.opts.stylePropPackageName) {
          throw path.buildCodeFrameError(
            `
Found \`${state.opts.stylePropName}\` prop but you didn't specify the path to the custom createElement in the Babel configuration.
Please set the \`stylePropPackageName\` option.

{
  "plugins": [
    [
      "style-sheet/babel",
      {
        "stylePropName": "${state.opts.stylePropName}",
        "stylePropPackageName": "./path/to/createElement.js"
      }
    ]
  ]
}

Read more about how to create the style prop package at https://github.com/giuseppeg/style-sheet
`
          )
        }
      },
      ImportDeclaration(path, state) {
        const stylePropPackageName = state.opts.stylePropPackageName;
        state.needsStylePropImport = Boolean(stylePropPackageName);
        state.hasStylePropImport =
          path.node.source.value === stylePropPackageName;

        const packageName = state.opts.packageName || 'style-sheet';
        if (path.node.source.value !== packageName) {
          return
        }
        const importName = state.opts.importName || 'StyleSheet';
        const specifier = path.get('specifiers').find(specifier => {
          return (
            specifier.isImportSpecifier() &&
            specifier.get('imported').node.name === importName
          )
        });
        if (!specifier) {
          return
        }

        state.hasStyleSheetImport = true;

        // Find all the references to StyleSheet.create.
        const binding = path.scope.getBinding(specifier.node.local.name);

        if (!binding || !Array.isArray(binding.referencePaths)) {
          return
        }

        binding.referencePaths
          .map(referencePath => referencePath.parentPath.parentPath)
          .forEach(path => {
            if (path.isCallExpression()) {
              processReferencePath(babel, path, state);
            }
          });
      },
    },
  }
}

function processReferencePath(babel, path, state) {
  const t = babel.types;
  const cloneNode = t.cloneNode || t.cloneDeep;
  // From
  //
  //   StyleSheet.create({
  //     root: {
  //       color: 'red'
  //     }
  //   })
  //
  // grabs
  //
  //   {
  //     root: {
  //       color: 'red'
  //     }
  //   }
  const rulesPath = path.get('arguments')[0];
  const extractableProperties = [];

  // For each property
  //
  //   root: {
  //     color: 'red'
  //   }
  const properties = rulesPath.get('properties');
  properties.forEach(property => {
    // Ignore complex stuff like spread elements for now.
    if (!property.isObjectProperty()) {
      return
    }
    // Try to resolve to static...
    // evaluate() will also compile static styles, which are the ones
    // that we will extract to file.
    const evaluated = evaluate(babel, property.get('value'), state);

    if (evaluated.value === null) {
      return
    }
    extractableProperties.push(
      t.objectProperty(
        cloneNode(property.get('key').node),
        t.arrayExpression(evaluated.value.map(value => t.stringLiteral(value)))
      )
    );
    property.remove();
  });

  // If we couldn't resolve anything we exit.
  if (extractableProperties.length === 0) {
    state.needsStyleSheetImport = true;
    return
  }

  const extractedStylesObjectLiteral = t.objectExpression(extractableProperties);

  // When some rules could not be extracted (maybe there are dynamic styles)
  // we will spread StyleSheet.create({...}) to the replacement object
  //
  //   ({
  //    static: [/* ... */],
  //    ...StyleSheet.create({
  //      someDynamicRule: {
  //        color: props.color,
  //      }
  //    })
  //   })
  if (properties.length !== extractableProperties.length) {
    state.needsStyleSheetImport = true;
    extractedStylesObjectLiteral.properties.push(
      t.spreadElement(cloneNode(path.node))
    );
  }
  path.replaceWith(extractedStylesObjectLiteral);
}

function compileRule(rule) {
  const compiled = StyleSheet.create({ static: rule }).static;
  StyleResolver.resolve(compiled);
  return compiled
}

function evaluate(babel, path, state) {
  let result = evaluateSimple(path);
  if (result.confident) {
    return {
      value: compileRule(result.value),
      dependencies: [],
    }
  }

  try {
    result = evaluateComplex(
      path,
      babel.types,
      state.file.opts.filename,
      text => {
        return babel.transformSync(text, {
          babelrc: false,
          filename: state.file.opts.filename,
          plugins: [
            // Include this plugin to avoid extra config when using { module: false } for webpack
            '@babel/plugin-transform-modules-commonjs',
            '@babel/plugin-proposal-export-namespace-from',
            // We don't support dynamic imports when evaluating, but don't wanna syntax error
            // This will replace dynamic imports with an object that does nothing
            // eslint-disable-next-line no-undef
            require.resolve('linaria/lib/babel/dynamic-import-noop'),
          ],
          exclude: /node_modules/,
        })
      }
    );

    if (result.value !== null) {
      result.value = compileRule(result.value);
    }
  } catch (error) {
    result = { value: null, dependencies: [] };
  }

  return result
}

exports.default = babel;
exports.getCss = getCss;
