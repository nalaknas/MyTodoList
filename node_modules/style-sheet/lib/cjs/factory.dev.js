'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var hashFn = _interopDefault(require('fnv1a'));
var inlineStylePrefixer = require('inline-style-prefixer');

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var unitless = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var shortHandProperties = ['animation', 'background', 'border', 'border-bottom', 'border-left', 'border-radius', 'border-right', 'border-top', 'column-rule', 'columns', 'flex', 'flex-flow', 'font', 'grid', 'grid-area', 'grid-column', 'grid-row', 'grid-template', 'list-style', 'margin', 'offset', 'outline', 'overflow', 'padding', 'place-content', 'place-items', 'place-self', 'text-decoration', 'transition'];
var i18n = {
  properties: {
    borderTopLeftRadius: 'borderTopRightRadius',
    borderTopRightRadius: 'borderTopLeftRadius',
    borderBottomLeftRadius: 'borderBottomRightRadius',
    borderBottomRightRadius: 'borderBottomLeftRadius',
    borderLeftColor: 'borderRightColor',
    borderLeftStyle: 'borderRightStyle',
    borderLeftWidth: 'borderRightWidth',
    borderRightColor: 'borderLeftColor',
    borderRightStyle: 'borderLeftStyle',
    borderRightWidth: 'borderLeftWidth',
    left: 'right',
    marginLeft: 'marginRight',
    marginRight: 'marginLeft',
    paddingLeft: 'paddingRight',
    paddingRight: 'paddingLeft',
    right: 'left'
  },
  values: {
    ltr: 'rtl',
    rtl: 'ltr',
    left: 'right',
    right: 'left',
    wResize: 'eResize',
    eResize: 'wResize',
    swResize: 'seResize',
    seResize: 'swResize',
    nwResize: 'neResize',
    neResize: 'nwResize'
  }
};

// adapted from styletron - https://raw.githubusercontent.com/styletron/styletron/c157e2a3a2592d639ae665342b2c0be8774e916b/packages/styletron-engine-atomic/src/sort-css-media-queries.js
var minMaxWidth = /(!?\(\s*min(-device-)?-width).+\(\s*max(-device)?-width/i;
var minWidth = /\(\s*min(-device)?-width/i;
var maxMinWidth = /(!?\(\s*max(-device)?-width).+\(\s*min(-device)?-width/i;
var maxWidth = /\(\s*max(-device)?-width/i;

var isMinWidth = _testQuery(minMaxWidth, maxMinWidth, minWidth);

var isMaxWidth = _testQuery(maxMinWidth, minMaxWidth, maxWidth);

var minMaxHeight = /(!?\(\s*min(-device)?-height).+\(\s*max(-device)?-height/i;
var minHeight = /\(\s*min(-device)?-height/i;
var maxMinHeight = /(!?\(\s*max(-device)?-height).+\(\s*min(-device)?-height/i;
var maxHeight = /\(\s*max(-device)?-height/i;

var isMinHeight = _testQuery(minMaxHeight, maxMinHeight, minHeight);

var isMaxHeight = _testQuery(maxMinHeight, minMaxHeight, maxHeight);

var isPrint = /print/i;
var isPrintOnly = /^print$/i;
var maxValue = Number.MAX_VALUE;

function _getQueryLength(length) {
  var matches = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/.exec(length);

  if (matches === null) {
    return maxValue;
  }

  var number = matches[1];
  var unit = matches[2];

  switch (unit) {
    case 'ch':
      number = parseFloat(number) * 8.8984375;
      break;

    case 'em':
    case 'rem':
      number = parseFloat(number) * 16;
      break;

    case 'ex':
      number = parseFloat(number) * 8.296875;
      break;

    case 'px':
      number = parseFloat(number);
      break;
  }

  return +number;
}

function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
  return function (query) {
    if (doubleTestTrue.test(query)) {
      return true;
    } else if (doubleTestFalse.test(query)) {
      return false;
    }

    return singleTest.test(query);
  };
}

function _testIsPrint(a, b) {
  var isPrintA = isPrint.test(a);
  var isPrintOnlyA = isPrintOnly.test(a);
  var isPrintB = isPrint.test(b);
  var isPrintOnlyB = isPrintOnly.test(b);

  if (isPrintA && isPrintB) {
    if (!isPrintOnlyA && isPrintOnlyB) {
      return 1;
    }

    if (isPrintOnlyA && !isPrintOnlyB) {
      return -1;
    }

    return a.localeCompare(b);
  }

  if (isPrintA) {
    return 1;
  }

  if (isPrintB) {
    return -1;
  }

  return null;
}

function sortCSSmq(a, b) {
  if (a === '') {
    return -1;
  }

  if (b === '') {
    return 1;
  }

  var testIsPrint = _testIsPrint(a, b);

  if (testIsPrint !== null) {
    return testIsPrint;
  }

  var minA = isMinWidth(a) || isMinHeight(a);
  var maxA = isMaxWidth(a) || isMaxHeight(a);
  var minB = isMinWidth(b) || isMinHeight(b);
  var maxB = isMaxWidth(b) || isMaxHeight(b);

  if (minA && maxB) {
    return -1;
  }

  if (maxA && minB) {
    return 1;
  }

  var lengthA = _getQueryLength(a);

  var lengthB = _getQueryLength(b);

  if (lengthA === maxValue && lengthB === maxValue) {
    return a.localeCompare(b);
  } else if (lengthA === maxValue) {
    return 1;
  } else if (lengthB === maxValue) {
    return -1;
  }

  if (lengthA > lengthB) {
    if (maxA) {
      return -1;
    }

    return 1;
  }

  if (lengthA < lengthB) {
    if (maxA) {
      return 1;
    }

    return -1;
  }

  return a.localeCompare(b);
}

/**
 * This module is a fork of and modifies: https://git.io/fjceH
 *
 * The original source is (c) Nicolas Gallagher
 * and licensed under the MIT license found a thttps://git.io/fjceS
 */

/**
 * Order-based insertion of CSS.
 *
 * Each rule is associated with a numerically defined group.
 * Groups are ordered within the style sheet according to their number, with the
 * lowest first.
 *
 * Groups are implemented using marker rules. The selector of the first rule of
 * each group is used only to encode the group number for hydration. An
 * alternative implementation could rely on CSSMediaRule, allowing groups to be
 * treated as a sub-sheet, but the Edge implementation of CSSMediaRule is
 * broken.
 * https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule
 * https://gist.github.com/necolas/aa0c37846ad6bd3b05b727b959e82674
 */

function createOrderedCSSStyleSheet(sheet) {
  var groups = {};
  var selectors = {};
  /**
   * Hydrate approximate record from any existing rules in the sheet.
   */

  if (sheet != null) {
    var group;
    Array.prototype.forEach.call(sheet.cssRules, function (cssRule, i) {
      var cssText = cssRule.cssText; // Create record of existing selectors and rules

      if (cssText.indexOf('style-sheet-group') > -1) {
        group = decodeGroupRule(cssRule);
        groups[group] = {
          start: i,
          rules: [cssText],
          mq: []
        };
      } else {
        var selectorText = getSelectorText(cssText);

        if (selectorText != null) {
          selectors[selectorText.selector] = true;
          var index = groups[group].rules.length - 1;

          if (selectorText.media) {
            index = groups[group].mq.indexOf(selectorText.media);

            if (index === -1) {
              groups[group].mq.push(selectorText.media);
              groups[group].mq.sort(sortCSSmq);
              index = groups[group].mq.indexOf(selectorText.media);
            }
          }

          groups[group].rules.splice(index + 1, 0, cssText);
        }
      }
    });
  }

  function sheetInsert(sheet, group, text, index) {
    var orderedGroups = getOrderedGroups(groups);
    var groupIndex = orderedGroups.indexOf(group);
    var nextGroupIndex = groupIndex + 1;
    var nextGroup = orderedGroups[nextGroupIndex]; // Insert rule before the next group, or at the end of the stylesheet

    var position = nextGroup != null && groups[nextGroup].start != null ? groups[nextGroup].start - _typeof(index) === 'number' ? groups[group].rules.length - index : 0 : sheet.cssRules.length;
    var isInserted = insertRuleAt(sheet, text, position);

    if (isInserted) {
      // Set the starting index of the new group
      if (groups[group].start == null) {
        groups[group].start = position;
      } // Increment the starting index of all subsequent groups


      for (var i = nextGroupIndex; i < orderedGroups.length; i += 1) {
        var groupNumber = orderedGroups[i];
        var previousStart = groups[groupNumber].start;
        groups[groupNumber].start = previousStart + 1;
      }
    }

    return isInserted;
  }

  function getTextContent() {
    return getOrderedGroups(groups).reduce(function (text, group, index) {
      var rules = groups[group].rules;
      return text + (index > 0 ? '\n' : '') + rules.join('\n');
    }, '');
  }

  var OrderedCSSStyleSheet = {
    /**
     * The textContent of the style sheet.
     */
    getTextContent: getTextContent,

    /**
     * Returns the textContent of the style sheet and removes all the rules from it.
     */
    flush: function flush() {
      var textContent = getTextContent();
      groups = {};
      selectors = {};

      if (sheet != null) {
        Array.prototype.forEach.call(sheet.cssRules, function (_, i) {
          sheet.deleteRule(i);
        });
      }

      return textContent;
    },

    /**
     * Insert a rule into the style sheet
     */
    insertRule: function insertRule(cssText, groupValue, index) {
      var group = Number(groupValue);

      if (isNaN(group)) {
        throw new Error("".concat(groupValue, " - Invalid group. Use OrderedCSSStyleSheet.insertRule(cssText, groupId)"));
      } // Create a new group.


      if (groups[group] == null) {
        var markerRule = encodeGroupRule(group); // Create the internal record.

        groups[group] = {
          start: null,
          rules: [markerRule],
          mq: []
        }; // Update CSSOM.

        if (sheet != null) {
          sheetInsert(sheet, group, markerRule);
        }
      } // selectorText is more reliable than cssText for insertion checks. The
      // browser excludes vendor-prefixed properties and rewrites certain values
      // making cssText more likely to be different from what was inserted.


      var selectorText = getSelectorText(cssText);

      if (selectorText != null && selectors[selectorText.selector] == null) {
        selectors[selectorText.selector] = true;

        if (typeof index !== 'number') {
          index = groups[group].rules.length - 1;

          if (selectorText.media) {
            index = groups[group].mq.indexOf(selectorText.media);

            if (index === -1) {
              groups[group].mq.push(selectorText.media);
              groups[group].mq.sort(sortCSSmq);
              index = groups[group].mq.indexOf(selectorText.media);
            }
          }
        }

        if (index > groups[group].rules.length - 1) {
          throw new Error("index ".concat(index, " out of bound for group ").concat(group));
        }

        groups[group].rules.splice(index + 1, 0, cssText); // Update CSSOM.

        if (sheet != null) {
          var isInserted = sheetInsert(sheet, group, cssText, index);

          if (!isInserted) {
            // Revert internal record change if a rule was rejected (e.g.,
            // unrecognized pseudo-selector)
            groups[group].rules.splice(index + 1, 1);
          }
        }
      }
    }
  };
  return OrderedCSSStyleSheet;
}
/**
 * Helper functions
 */

function encodeGroupRule(group) {
  return "[style-sheet-group=\"".concat(group, "\"]{}");
}

function decodeGroupRule(cssRule) {
  return Number(cssRule.selectorText.split(/["']/)[1]);
}

function getOrderedGroups(obj) {
  return Object.keys(obj).map(Number).sort(function (a, b) {
    return a > b ? 1 : -1;
  });
}

var pattern = /\s*([,])\s*/g;

function getSelectorText(cssText) {
  var split = cssText.split('{');
  var selector = split[0].trim();
  var media = null;

  if (selector.startsWith('@media')) {
    media = selector.substring(6).trim();
    selector = split[1].trim();
  }

  return selector !== '' ? {
    media: media,
    selector: selector.replace(pattern, '$1')
  } : null;
}

function insertRuleAt(root, cssText, position) {
  try {
    root.insertRule(cssText, position);
    return true;
  } catch (e) {
    // JSDOM doesn't support `CSSSMediaRule#insertRule`.
    // Also ignore errors that occur from attempting to insert vendor-prefixed selectors.
    return false;
  }
}

var STYLE_GROUPS = ['classic', 'mediaClassic', 'shorthand', 'mediaShorthand', 'shorthandCombinator', 'mediaShorthandCombinator', 'i18nShorthand', 'mediaI18nShorthand', 'i18nShorthandCombinator', 'mediaI18nShorthandCombinator', 'atomic', 'mediaAtomic', 'atomicCombinator', 'mediaAtomicCombinator'].reduce(function (groups, name, index) {
  groups[name] = index;
  return groups;
}, {});

function createClassName(property, value, descendants, media) {
  var ruleType = getRuleType(property, media, descendants);
  return "dss".concat(ruleType, "_").concat(hashFn(property + descendants + media).toString(36), "-").concat(hashFn(String(value)).toString(36));
}

var hyphenate = function hyphenate(s) {
  return s.replace(/[A-Z]|^ms/g, '-$&').toLowerCase();
};

var strigifyDeclaration = function strigifyDeclaration(dec) {
  var stringified = '';

  for (var prop in dec) {
    var value = dec[prop];

    if (Array.isArray(value)) {
      for (var i = 0; i < value.length; i++) {
        stringified += hyphenate(prop) + ':' + value[i] + ';';
      }
    } else {
      stringified += hyphenate(prop) + ':' + value + ';';
    }
  }

  return stringified;
};

function createRule(className, declaration, descendants, media) {
  var cls = '.' + className.replace('.', '\\.');
  var selector = descendants ? descendants.replace(/^&/, cls).replace(/&/g, cls) : cls;
  var rule = selector + '{' + strigifyDeclaration(declaration) + '}';
  if (!media) return rule;
  return media + '{' + rule + '}';
}
var order = {
  pseudo: ['link', 'visited', 'hover', 'focus-within', 'focus-visible', 'focus', 'active']
};

function getRuleType(prop, media, descendants) {
  var name = '';

  if (shortHandProperties.indexOf(prop) > -1) {
    name = media ? 'mediaShorthand' : 'shorthand';
  } else {
    name = media ? 'mediaAtomic' : 'atomic';
  }

  var subGroup = 0;

  if (descendants) {
    var subGroupPart; // is a combinator selector eg :hover > &

    if (descendants.substr(0, 2) !== '&:') {
      name += 'Combinator';
      subGroupPart = descendants.slice(1).split(/\s*[+>~]\s*/g)[0];
    } else {
      subGroupPart = descendants.slice(2);
    }

    var index = order.pseudo.indexOf(subGroupPart.split(':').slice(-1)[0]);

    if (index > -1) {
      subGroup = index + 1;
    }
  }

  return subGroup > 0 ? STYLE_GROUPS[name] + '.' + subGroup : STYLE_GROUPS[name];
}

function normalizeValue(value) {
  if (typeof value === 'number') {
    if (value !== 0) {
      return value + 'px';
    }
  } else if (Array.isArray(value)) {
    return value.map(function (v) {
      if (typeof v === 'number' && v !== 0) {
        return v + 'px';
      }

      return v;
    });
  }

  return value;
}

function toI18n(lookup, thing) {
  return Object.prototype.hasOwnProperty.call(lookup, thing) ? lookup[thing] : null;
}

var cache = {};

var parse = function parse(obj, descendants, media, opts) {
  var rules = {};

  for (var key in obj) {
    var value = obj[key];
    if (value === null || value === undefined) continue;

    switch (Object.prototype.toString.call(value)) {
      case '[object Object]':
        {
          var parsed = key.charAt(0) === '@' ? parse(value, descendants, key, opts) : parse(value, descendants + key, media, opts);
          Object.assign(rules, parsed);
          break;
        }

      default:
        {
          var cacheKey = key + value + descendants + media;
          var cached = cache[cacheKey];

          if (cached) {
            Object.assign(rules, cached);
            break;
          }

          var className = createClassName(key, value, descendants, media);

          if (rules[className]) {
            break;
          }

          if (!unitless[key]) {
            value = normalizeValue(value);
          }

          var declaration = inlineStylePrefixer.prefix(_defineProperty({}, key, value));
          var rule = createRule(className, declaration, descendants, media);

          if (opts.i18n) {
            var originalProp = key;
            var originalValue = value;
            key = toI18n(i18n.properties, originalProp);
            value = toI18n(i18n.values, originalValue);

            if (key !== null || value !== null) {
              key = key || originalProp;
              value = value || originalValue;
              var i18nClassName = createClassName(key, value, descendants, media); // i18n classNames contain both the ltr and rtl version
              // this is resolved at runtime by the StyleResolver

              className = "".concat(className, "|").concat(i18nClassName);

              var _declaration = inlineStylePrefixer.prefix(_defineProperty({}, key, value)); // i18n rule is an array with two rules the ltr and the rtl one
              // eg. ['.left { margin-left: 10px }', '.right { margin-right: 10px }']
              // At runtime the StyleResolver will pick the correct one.


              rule = [rule, createRule(i18nClassName, _declaration, descendants, media)];
            }
          }

          rules[className] = rule;
          cache[cacheKey] = _defineProperty({}, className, rule);
          break;
        }
    }
  }

  return rules;
};

var compile = (function (obj, opts) {
  if (!obj) {
    throw new Error('DSS parser invoked without a mandatory styles object.');
  }

  return parse(obj, '', '', opts);
});

function error(message) {
  throw new Error("style-sheet: ".concat(message));
}

function validate(obj) {
  for (var k in obj) {
    var key = k.trim();
    var value = obj[key];
    if (value === null) continue;
    var isDeclaration = Object.prototype.toString.call(value) !== '[object Object]';
    validateStr(key, isDeclaration);

    if (!isDeclaration) {
      validate(value);
    } else if (typeof value === 'string' && /!\s*important/.test(value)) {
      error('!important is not allowed');
    }
  }
}
function validateStr(key, isDeclaration) {
  if (isDeclaration) {
    return;
  }

  if (key.charAt(0) === '@') {
    return;
  } // Selector


  if (key.split(',').length > 1) {
    error("Invalid nested selector: '".concat(key, "'. Selectors cannot be grouped."));
  }

  if (/::?(after|before|first-letter|first-line)/.test(key)) {
    error("Detected pseudo-element: '".concat(key, "'. Pseudo-elements are not supported. Please use regular elements."));
  }

  if (/:(matches|has|not|lang|any|current)/.test(key)) {
    error("Detected unsupported pseudo-class: '".concat(key, "'."));
  }

  var split = key.split(/\s*[+>~]\s*/g);

  switch (split.length) {
    case 2:
      if (split[0].charAt(0) !== ':') {
        error("Invalid nested selector: '".concat(key, "'. ") + 'The left part of a combinator selector must be a pseudo-class eg. `:hover`.');
      }

      if (split[1] !== '&') {
        error("Invalid nested selector: '".concat(key, "'. ") + 'The right part of a combinator selector must be `&`.');
      }

      break;

    case 1:
      if (split[0].indexOf(' ') > -1) {
        error("Invalid nested selector: ".concat(key, ". Complex selectors are not supported."));
      }

      if (split[0].charAt(0) !== '&') {
        error("Invalid nested selector: '".concat(key, "'. ") + 'A pseudo-class selector should reference its parent with `&` eg. `&:hover {}`.');
      }

      break;

    default:
      error("Invalid nested selector: ".concat(key, "."));
  }

  if (/\[/.test(key)) {
    error("Invalid selector: ".concat(key, ". Cannot use attribute selectors, please use only class selectors."));
  }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var stackframe = createCommonjsModule(function (module, exports) {
(function(root, factory) {
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    {
        module.exports = factory();
    }
}(commonjsGlobal, function() {
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps);

    function StackFrame(obj) {
        if (obj instanceof Object) {
            for (var i = 0; i < props.length; i++) {
                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {
                    this['set' + _capitalize(props[i])](obj[props[i]]);
                }
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var fileName = this.getFileName() || '';
            var lineNumber = this.getLineNumber() || '';
            var columnNumber = this.getColumnNumber() || '';
            var functionName = this.getFunctionName() || '';
            if (this.getIsEval()) {
                if (fileName) {
                    return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
                }
                return '[eval]:' + lineNumber + ':' + columnNumber;
            }
            if (functionName) {
                return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
            }
            return fileName + ':' + lineNumber + ':' + columnNumber;
        }
    };

    StackFrame.fromString = function StackFrame$$fromString(str) {
        var argsStartIndex = str.indexOf('(');
        var argsEndIndex = str.lastIndexOf(')');

        var functionName = str.substring(0, argsStartIndex);
        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
        var locationString = str.substring(argsEndIndex + 1);

        if (locationString.indexOf('@') === 0) {
            var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
            var fileName = parts[1];
            var lineNumber = parts[2];
            var columnNumber = parts[3];
        }

        return new StackFrame({
            functionName: functionName,
            args: args || undefined,
            fileName: fileName,
            lineNumber: lineNumber || undefined,
            columnNumber: columnNumber || undefined
        });
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));
});

var errorStackParser = createCommonjsModule(function (module, exports) {
(function(root, factory) {
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    {
        module.exports = factory(stackframe);
    }
}(commonjsGlobal, function ErrorStackParser(StackFrame) {

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return filtered.map(function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, '');
                }
                var sanitizedLine = line.replace(/^\s+/, '').replace(/\(eval code/g, '(');

                // capture and preseve the parenthesized location "(/foo/my bar.js:12:87)" in
                // case it has spaces in it, as the string is split on \s+ later on
                var location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/);

                // remove the parenthesized location from the line, if it was matched
                sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;

                var tokens = sanitizedLine.split(/\s+/).slice(1);
                // if a location was matched, pass it to extractLocation() otherwise pop the last token
                var locationParts = this.extractLocation(location ? location[1] : tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame({
                    functionName: functionName,
                    fileName: fileName,
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return filtered.map(function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame({
                        functionName: line
                    });
                } else {
                    var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
                    var matches = line.match(functionNameRegex);
                    var functionName = matches && matches[1] ? matches[1] : undefined;
                    var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));

                    return new StackFrame({
                        functionName: functionName,
                        fileName: locationParts[0],
                        lineNumber: locationParts[1],
                        columnNumber: locationParts[2],
                        source: line
                    });
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame({
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                    }));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame({
                            functionName: match[3] || undefined,
                            fileName: match[2],
                            lineNumber: match[1],
                            source: lines[i]
                        })
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return filtered.map(function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                        .replace(/<anonymous function(: (\w+))?>/, '$2')
                        .replace(/\([^\)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^\)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');

                return new StackFrame({
                    functionName: functionName,
                    args: args,
                    fileName: locationParts[0],
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        }
    };
}));
});

/* global Blob, Worker, URL, module */
function createSourceMapsEngine() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$baseUrl = _ref.baseUrl,
      baseUrl = _ref$baseUrl === void 0 ? 'https://unpkg.com/css-to-js-sourcemap-worker@2.0.5' : _ref$baseUrl,
      _ref$renderInterval = _ref.renderInterval,
      renderInterval = _ref$renderInterval === void 0 ? 120 : _ref$renderInterval;

  var workerBlob = new Blob(["importScripts(\"".concat(baseUrl, "/worker.js\")")], {
    type: 'application/javascript'
  });
  var worker = new Worker(URL.createObjectURL(workerBlob));
  worker.postMessage({
    id: 'init_wasm',
    url: "".concat(baseUrl, "/mappings.wasm")
  });
  var style = document.createElement('style');
  document.head.appendChild(style);
  worker.postMessage({
    id: 'set_render_interval',
    interval: renderInterval
  });

  if (module && module.hot) {
    module.hot.addStatusHandler(function (status) {
      if (status === 'dispose') {
        worker.postMessage({
          id: 'invalidate'
        });
      }
    });
  }

  worker.onmessage = function (msg) {
    var _msg$data = msg.data,
        id = _msg$data.id,
        css = _msg$data.css;

    if (id === 'render_css' && css) {
      style.appendChild(document.createTextNode(css));
    }
  };

  var counter = 0;
  return {
    create: function create() {
      var className = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "__debug";
      var stackIndex = 3;
      var error = new Error('stacktrace source');
      var prefix = getDebugClassName(error, stackIndex);
      var cls = typeof className === 'function' ? className(prefix, counter) : className + '-' + counter;
      counter++;
      worker.postMessage({
        id: 'add_mapped_class',
        className: cls,
        stackInfo: {
          stack: error.stack,
          message: error.message
        },
        stackIndex: stackIndex
      });
      return cls;
    }
  };
}
function getDebugClassName(error) {
  var stackIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var line = errorStackParser.parse(error)[stackIndex];

  if (!line || !line.fileName) {
    return '__dss-debug';
  }

  var parts = line.fileName.split('/');
  var name = parts.pop().replace(/\..*$/, '');

  if (name === 'index') {
    name = parts.pop();
  }

  name = name.replace(/\W/g, '-');
  return name.charAt(0).toUpperCase() + name.slice(1);
}

var isBrowser = typeof window !== 'undefined';
var isProd = "development" === 'production';

function createStyleSheet(rules, opts) {
  var cache = typeof Map === 'undefined' ? null : new Map();
  var sourceMapsEngine;

  if ( !isBrowser && typeof Worker !== 'undefined') {
    sourceMapsEngine = createSourceMapsEngine();
  }

  return {
    create: function create(styles) {
      if (cache) {
        var cached = cache.get(styles);

        if (cached) {
          return cached;
        }
      }

      var locals = {};

      var _loop = function _loop(token) {
        var rule = styles[token];

        {
          validate(rule);
        }

        var compiled = compile(rule, opts);
        Object.assign(rules, compiled);
        locals[token] = Object.keys(compiled); // In dev add source maps

        if ( sourceMapsEngine) {
          locals[token].unshift(sourceMapsEngine.create(function (prefix, id) {
            return opts.sourceMaps.className({
              prefix: prefix,
              key: token,
              id: id
            });
          }));
        }
      };

      for (var token in styles) {
        _loop(token);
      }

      if (cache) {
        cache.set(styles, locals);
      }

      return locals;
    }
  };
}

function concatClassName(dest, className) {
  if (className.substr(0, 3) !== 'dss') {
    return {
      shouldInject: false,
      className: "".concat(className, " ").concat(dest),
      group: null
    };
  }

  var property = className.substr(0, className.indexOf('-'));

  if (dest.indexOf(property) > -1) {
    return {
      shouldInject: false,
      className: dest,
      group: null
    };
  }

  return {
    shouldInject: true,
    className: "".concat(dest, " ").concat(className),
    group: Number(className.substring(3, className.indexOf('_')).replace('\\', ''))
  };
}

function createStyleResolver(sheet, rules, opts) {
  var resolved = {};
  var injected = {};
  return {
    getStyleSheet: function getStyleSheet() {
      // On the server we reset the caches.
      if (typeof window === 'undefined') {
        resolved = {};
        injected = {};
      }

      return sheet;
    },
    resolve: function resolve(style) {
      var i18n = opts.i18n || {};
      var stylesToString = i18n.isRTL + i18n.doLeftAndRightSwapInRTL + style.join();

      if (resolved[stylesToString]) {
        return resolved[stylesToString];
      }

      var resolvedClassName = '';

      for (var i = style.length - 1; i >= 0; i--) {
        var current = style[i];

        if (!current) {
          continue;
        }

        if (typeof current === 'string') {
          current = [current];
        }

        for (var j = 0; j < current.length; j++) {
          var className = current[j];
          var rule = void 0; // resolve i18n rules

          var i18nClassNames = className.split('|');
          var i18nRules = void 0;
          var i18nIndex = void 0;

          if (i18nClassNames.length > 1) {
            if (i18n.isRTL && i18n.doLeftAndRightSwapInRTL) {
              i18nIndex = 1;
            } else {
              i18nIndex = 0;
            }

            i18nRules = rules[className];
            className = i18nClassNames[i18nIndex];
            rule = i18nRules[i18nIndex];
          } else {
            rule = rules[className];
          }

          var result = concatClassName(resolvedClassName, className);
          resolvedClassName = result.className;

          if (result.shouldInject && !injected[className]) {
            if (rule) {
              sheet.insertRule(rule, result.group);

              if (i18nRules && !isBrowser) {
                var i18nIndexInverse = i18nIndex ? 0 : 1;
                sheet.insertRule(i18nRules[i18nIndexInverse], result.group);
                injected[i18nClassNames[i18nIndexInverse]] = true;
              }
            }

            injected[className] = true;
          }
        }
      }

      resolvedClassName = resolvedClassName.trim();
      resolved[stylesToString] = resolvedClassName;
      return resolvedClassName;
    }
  };
}

function createSheet(document) {
  document = document || typeof window === 'undefined' ? null : window.document;
  var sheet = null;

  if (document) {
    var style = document.createElement('style');
    document.head.appendChild(style);
    sheet = style.sheet;
  }

  return sheet;
}
function create() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var i18n;

  function setI18nManager(manager) {
    i18n = manager;

    if (i18n && !isProd) {
      if (typeof i18n.isRTL !== 'boolean') {
        throw new Error('i18n.isRTL must be a boolean.');
      }

      if (typeof i18n.doLeftAndRightSwapInRTL !== 'boolean') {
        throw new Error('i18n.doLeftAndRightSwapInRTL must be a boolean.');
      }
    }
  }

  setI18nManager(options.i18n);
  var sheet = createOrderedCSSStyleSheet(options.sheet || createSheet());
  var rules = {};
  var opts = {
    get i18n() {
      return i18n;
    }

  };

  {
    opts.sourceMaps = Object.assign({
      className: function className(_ref) {
        var prefix = _ref.prefix,
            key = _ref.key,
            id = _ref.id;
        return "".concat(prefix, "__").concat(key, "-").concat(id);
      }
    }, options.sourceMaps || {});
  }

  return {
    StyleSheet: createStyleSheet(rules, opts),
    StyleResolver: createStyleResolver(sheet, rules, opts),
    setI18nManager: setI18nManager
  };
}

exports.create = create;
exports.createSheet = createSheet;
