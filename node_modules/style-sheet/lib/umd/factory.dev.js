(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.styleSheetFactory = {}));
}(this, function (exports) { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  /**
   * Created by schwarzkopfb on 15/11/17.
   */

  /**
   * FNV-1a hash generation init value.
   * It's exposed, because this allows user to override it.
   *
   * @type {number}
   */
  hash.BASE = 0x811c9dc5;

  /**
   * Generates 32 bit FNV-1a hash from the given string.
   * As explained here: http://isthe.com/chongo/tech/comp/fnv/
   *
   * @param s {string} String to generate hash from.
   * @returns {number} The result integer hash.
   */
  function hash(s) {
      var h = hash.BASE;

      for (var i = 0, l = s.length; i < l; i++) {
          h ^= s.charCodeAt(i);
          h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
      }

      return h >>> 0
  }

  var fnv1a = hash;

  function capitalizeString(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  function prefixProperty(prefixProperties, property, style) {
    if (prefixProperties.hasOwnProperty(property)) {
      var newStyle = {};
      var requiredPrefixes = prefixProperties[property];
      var capitalizedProperty = capitalizeString(property);
      var keys = Object.keys(style);
      for (var i = 0; i < keys.length; i++) {
        var styleProperty = keys[i];
        if (styleProperty === property) {
          for (var j = 0; j < requiredPrefixes.length; j++) {
            newStyle[requiredPrefixes[j] + capitalizedProperty] = style[property];
          }
        }
        newStyle[styleProperty] = style[styleProperty];
      }
      return newStyle;
    }
    return style;
  }

  function prefixValue(plugins, property, value, style, metaData) {
    for (var i = 0, len = plugins.length; i < len; ++i) {
      var processedValue = plugins[i](property, value, style, metaData);

      // we can stop processing if a value is returned
      // as all plugin criteria are unique
      if (processedValue) {
        return processedValue;
      }
    }
  }

  function addIfNew(list, value) {
    if (list.indexOf(value) === -1) {
      list.push(value);
    }
  }

  function addNewValuesOnly(list, values) {
    if (Array.isArray(values)) {
      for (var i = 0, len = values.length; i < len; ++i) {
        addIfNew(list, values[i]);
      }
    } else {
      addIfNew(list, values);
    }
  }

  function isObject(value) {
    return value instanceof Object && !Array.isArray(value);
  }

  function createPrefixer(_ref) {
    var prefixMap = _ref.prefixMap,
        plugins = _ref.plugins;

    return function prefix(style) {
      for (var property in style) {
        var value = style[property];

        // handle nested objects
        if (isObject(value)) {
          style[property] = prefix(value);
          // handle array values
        } else if (Array.isArray(value)) {
          var combinedValue = [];

          for (var i = 0, len = value.length; i < len; ++i) {
            var processedValue = prefixValue(plugins, property, value[i], style, prefixMap);
            addNewValuesOnly(combinedValue, processedValue || value[i]);
          }

          // only modify the value if it was touched
          // by any plugin to prevent unnecessary mutations
          if (combinedValue.length > 0) {
            style[property] = combinedValue;
          }
        } else {
          var _processedValue = prefixValue(plugins, property, value, style, prefixMap);

          // only modify the value if it was touched
          // by any plugin to prevent unnecessary mutations
          if (_processedValue) {
            style[property] = _processedValue;
          }

          style = prefixProperty(prefixMap, property, style);
        }
      }

      return style;
    };
  }

  var w = ["Webkit"];
  var m = ["Moz"];
  var ms = ["ms"];
  var wm = ["Webkit", "Moz"];
  var wms = ["Webkit", "ms"];
  var wmms = ["Webkit", "Moz", "ms"];

  var data = {
    plugins: [],
    prefixMap: { "appearance": wm, "textEmphasisPosition": w, "textEmphasis": w, "textEmphasisStyle": w, "textEmphasisColor": w, "boxDecorationBreak": w, "maskImage": w, "maskMode": w, "maskRepeat": w, "maskPosition": w, "maskClip": w, "maskOrigin": w, "maskSize": w, "maskComposite": w, "mask": w, "maskBorderSource": w, "maskBorderMode": w, "maskBorderSlice": w, "maskBorderWidth": w, "maskBorderOutset": w, "maskBorderRepeat": w, "maskBorder": w, "maskType": w, "textDecorationStyle": w, "textDecorationSkip": w, "textDecorationLine": w, "textDecorationColor": w, "userSelect": wmms, "backdropFilter": w, "fontKerning": w, "scrollSnapType": wms, "scrollSnapPointsX": wms, "scrollSnapPointsY": wms, "scrollSnapDestination": wms, "scrollSnapCoordinate": wms, "clipPath": w, "shapeImageThreshold": w, "shapeImageMargin": w, "shapeImageOutside": w, "filter": w, "hyphens": wms, "flowInto": wms, "flowFrom": wms, "breakBefore": wms, "breakAfter": wms, "breakInside": wms, "regionFragment": wms, "writingMode": wms, "textOrientation": w, "tabSize": m, "fontFeatureSettings": w, "columnCount": w, "columnFill": w, "columnGap": w, "columnRule": w, "columnRuleColor": w, "columnRuleStyle": w, "columnRuleWidth": w, "columns": w, "columnSpan": w, "columnWidth": w, "wrapFlow": ms, "wrapThrough": ms, "wrapMargin": ms, "textSizeAdjust": wms }
  };

  // https://developer.mozilla.org/en-US/docs/Web/CSS/background-clip#Browser_compatibility
  function backgroundClip(property, value) {
    if (typeof value === 'string' && value === 'text') {
      return ['-webkit-text', 'text'];
    }
  }

  var prefixes = ['-webkit-', '-moz-', ''];

  var values = {
    'zoom-in': true,
    'zoom-out': true,
    grab: true,
    grabbing: true
  };

  function cursor(property, value) {
    if (property === 'cursor' && values.hasOwnProperty(value)) {
      return prefixes.map(function (prefix) {
        return prefix + value;
      });
    }
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var isPrefixedValue_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPrefixedValue;
  var regex = /-webkit-|-moz-|-ms-/;

  function isPrefixedValue(value) {
    return typeof value === 'string' && regex.test(value);
  }
  module.exports = exports['default'];
  });

  var isPrefixedValue = unwrapExports(isPrefixedValue_1);

  // http://caniuse.com/#search=cross-fade
  var prefixes$1 = ['-webkit-', ''];

  function crossFade(property, value) {
    if (typeof value === 'string' && !isPrefixedValue(value) && value.indexOf('cross-fade(') > -1) {
      return prefixes$1.map(function (prefix) {
        return value.replace(/cross-fade\(/g, prefix + 'cross-fade(');
      });
    }
  }

  // http://caniuse.com/#feat=css-filter-function
  var prefixes$2 = ['-webkit-', ''];

  function filter(property, value) {
    if (typeof value === 'string' && !isPrefixedValue(value) && value.indexOf('filter(') > -1) {
      return prefixes$2.map(function (prefix) {
        return value.replace(/filter\(/g, prefix + 'filter(');
      });
    }
  }

  var values$1 = {
    flex: ['-webkit-box', '-moz-box', '-ms-flexbox', '-webkit-flex', 'flex'],
    'inline-flex': ['-webkit-inline-box', '-moz-inline-box', '-ms-inline-flexbox', '-webkit-inline-flex', 'inline-flex']
  };

  function flex(property, value) {
    if (property === 'display' && values$1.hasOwnProperty(value)) {
      return values$1[value];
    }
  }

  var alternativeValues = {
    'space-around': 'justify',
    'space-between': 'justify',
    'flex-start': 'start',
    'flex-end': 'end',
    'wrap-reverse': 'multiple',
    wrap: 'multiple'
  };

  var alternativeProps = {
    alignItems: 'WebkitBoxAlign',
    justifyContent: 'WebkitBoxPack',
    flexWrap: 'WebkitBoxLines',
    flexGrow: 'WebkitBoxFlex'
  };

  function flexboxOld(property, value, style) {
    if (property === 'flexDirection' && typeof value === 'string') {
      if (value.indexOf('column') > -1) {
        style.WebkitBoxOrient = 'vertical';
      } else {
        style.WebkitBoxOrient = 'horizontal';
      }
      if (value.indexOf('reverse') > -1) {
        style.WebkitBoxDirection = 'reverse';
      } else {
        style.WebkitBoxDirection = 'normal';
      }
    }
    if (alternativeProps.hasOwnProperty(property)) {
      style[alternativeProps[property]] = alternativeValues[value] || value;
    }
  }

  var prefixes$3 = ['-webkit-', '-moz-', ''];
  var values$2 = /linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient/gi;

  function gradient(property, value) {
    if (typeof value === 'string' && !isPrefixedValue(value) && values$2.test(value)) {
      return prefixes$3.map(function (prefix) {
        return value.replace(values$2, function (grad) {
          return prefix + grad;
        });
      });
    }
  }

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  function isSimplePositionValue(value) {
    return typeof value === 'number' && !isNaN(value);
  }

  var alignmentValues = ['center', 'end', 'start', 'stretch'];

  var displayValues = {
    'inline-grid': ['-ms-inline-grid', 'inline-grid'],
    grid: ['-ms-grid', 'grid']
  };

  var propertyConverters = {
    alignSelf: function alignSelf(value, style) {
      if (alignmentValues.indexOf(value) > -1) {
        style.msGridRowAlign = value;
      }
    },

    gridColumn: function gridColumn(value, style) {
      if (isSimplePositionValue(value)) {
        style.msGridColumn = value;
      } else {
        var _value$split$map = value.split('/').map(function (position) {
          return +position;
        }),
            _value$split$map2 = _slicedToArray(_value$split$map, 2),
            start = _value$split$map2[0],
            end = _value$split$map2[1];

        propertyConverters.gridColumnStart(start, style);
        propertyConverters.gridColumnEnd(end, style);
      }
    },

    gridColumnEnd: function gridColumnEnd(value, style) {
      var msGridColumn = style.msGridColumn;

      if (isSimplePositionValue(value) && isSimplePositionValue(msGridColumn)) {
        style.msGridColumnSpan = value - msGridColumn;
      }
    },

    gridColumnStart: function gridColumnStart(value, style) {
      if (isSimplePositionValue(value)) {
        style.msGridColumn = value;
      }
    },

    gridRow: function gridRow(value, style) {
      if (isSimplePositionValue(value)) {
        style.msGridRow = value;
      } else {
        var _value$split$map3 = value.split('/').map(function (position) {
          return +position;
        }),
            _value$split$map4 = _slicedToArray(_value$split$map3, 2),
            start = _value$split$map4[0],
            end = _value$split$map4[1];

        propertyConverters.gridRowStart(start, style);
        propertyConverters.gridRowEnd(end, style);
      }
    },

    gridRowEnd: function gridRowEnd(value, style) {
      var msGridRow = style.msGridRow;

      if (isSimplePositionValue(value) && isSimplePositionValue(msGridRow)) {
        style.msGridRowSpan = value - msGridRow;
      }
    },

    gridRowStart: function gridRowStart(value, style) {
      if (isSimplePositionValue(value)) {
        style.msGridRow = value;
      }
    },

    gridTemplateColumns: function gridTemplateColumns(value, style) {
      style.msGridColumns = value;
    },

    gridTemplateRows: function gridTemplateRows(value, style) {
      style.msGridRows = value;
    },

    justifySelf: function justifySelf(value, style) {
      if (alignmentValues.indexOf(value) > -1) {
        style.msGridColumnAlign = value;
      }
    }
  };

  function grid(property, value, style) {
    if (property === 'display' && value in displayValues) {
      return displayValues[value];
    }

    if (property in propertyConverters) {
      var propertyConverter = propertyConverters[property];
      propertyConverter(value, style);
    }
  }

  // http://caniuse.com/#feat=css-image-set
  var prefixes$4 = ['-webkit-', ''];

  function imageSet(property, value) {
    if (typeof value === 'string' && !isPrefixedValue(value) && value.indexOf('image-set(') > -1) {
      return prefixes$4.map(function (prefix) {
        return value.replace(/image-set\(/g, prefix + 'image-set(');
      });
    }
  }

  var alternativeProps$1 = {
    marginBlockStart: ['WebkitMarginBefore'],
    marginBlockEnd: ['WebkitMarginAfter'],
    marginInlineStart: ['WebkitMarginStart', 'MozMarginStart'],
    marginInlineEnd: ['WebkitMarginEnd', 'MozMarginEnd'],
    paddingBlockStart: ['WebkitPaddingBefore'],
    paddingBlockEnd: ['WebkitPaddingAfter'],
    paddingInlineStart: ['WebkitPaddingStart', 'MozPaddingStart'],
    paddingInlineEnd: ['WebkitPaddingEnd', 'MozPaddingEnd'],
    borderBlockStart: ['WebkitBorderBefore'],
    borderBlockStartColor: ['WebkitBorderBeforeColor'],
    borderBlockStartStyle: ['WebkitBorderBeforeStyle'],
    borderBlockStartWidth: ['WebkitBorderBeforeWidth'],
    borderBlockEnd: ['WebkitBorderAfter'],
    borderBlockEndColor: ['WebkitBorderAfterColor'],
    borderBlockEndStyle: ['WebkitBorderAfterStyle'],
    borderBlockEndWidth: ['WebkitBorderAfterWidth'],
    borderInlineStart: ['WebkitBorderStart', 'MozBorderStart'],
    borderInlineStartColor: ['WebkitBorderStartColor', 'MozBorderStartColor'],
    borderInlineStartStyle: ['WebkitBorderStartStyle', 'MozBorderStartStyle'],
    borderInlineStartWidth: ['WebkitBorderStartWidth', 'MozBorderStartWidth'],
    borderInlineEnd: ['WebkitBorderEnd', 'MozBorderEnd'],
    borderInlineEndColor: ['WebkitBorderEndColor', 'MozBorderEndColor'],
    borderInlineEndStyle: ['WebkitBorderEndStyle', 'MozBorderEndStyle'],
    borderInlineEndWidth: ['WebkitBorderEndWidth', 'MozBorderEndWidth']
  };

  function logical(property, value, style) {
    if (Object.prototype.hasOwnProperty.call(alternativeProps$1, property)) {
      var alternativePropList = alternativeProps$1[property];
      for (var i = 0, len = alternativePropList.length; i < len; ++i) {
        style[alternativePropList[i]] = value;
      }
    }
  }

  function position(property, value) {
    if (property === 'position' && value === 'sticky') {
      return ['-webkit-sticky', 'sticky'];
    }
  }

  var prefixes$5 = ['-webkit-', '-moz-', ''];

  var properties = {
    maxHeight: true,
    maxWidth: true,
    width: true,
    height: true,
    columnWidth: true,
    minWidth: true,
    minHeight: true
  };
  var values$3 = {
    'min-content': true,
    'max-content': true,
    'fill-available': true,
    'fit-content': true,
    'contain-floats': true
  };

  function sizing(property, value) {
    if (properties.hasOwnProperty(property) && values$3.hasOwnProperty(value)) {
      return prefixes$5.map(function (prefix) {
        return prefix + value;
      });
    }
  }

  /* eslint-disable no-var, prefer-template */
  var uppercasePattern = /[A-Z]/g;
  var msPattern = /^ms-/;
  var cache = {};

  function toHyphenLower(match) {
    return '-' + match.toLowerCase()
  }

  function hyphenateStyleName(name) {
    if (cache.hasOwnProperty(name)) {
      return cache[name]
    }

    var hName = name.replace(uppercasePattern, toHyphenLower);
    return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
  }

  var hyphenateProperty_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = hyphenateProperty;



  var _hyphenateStyleName2 = _interopRequireDefault(hyphenateStyleName);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function hyphenateProperty(property) {
    return (0, _hyphenateStyleName2.default)(property);
  }
  module.exports = exports['default'];
  });

  var hyphenateProperty = unwrapExports(hyphenateProperty_1);

  var properties$1 = {
    transition: true,
    transitionProperty: true,
    WebkitTransition: true,
    WebkitTransitionProperty: true,
    MozTransition: true,
    MozTransitionProperty: true
  };

  var prefixMapping = {
    Webkit: '-webkit-',
    Moz: '-moz-',
    ms: '-ms-'
  };

  function prefixValue$1(value, propertyPrefixMap) {
    if (isPrefixedValue(value)) {
      return value;
    }

    // only split multi values, not cubic beziers
    var multipleValues = value.split(/,(?![^()]*(?:\([^()]*\))?\))/g);

    for (var i = 0, len = multipleValues.length; i < len; ++i) {
      var singleValue = multipleValues[i];
      var values = [singleValue];
      for (var property in propertyPrefixMap) {
        var dashCaseProperty = hyphenateProperty(property);

        if (singleValue.indexOf(dashCaseProperty) > -1 && dashCaseProperty !== 'order') {
          var prefixes = propertyPrefixMap[property];
          for (var j = 0, pLen = prefixes.length; j < pLen; ++j) {
            // join all prefixes and create a new value
            values.unshift(singleValue.replace(dashCaseProperty, prefixMapping[prefixes[j]] + dashCaseProperty));
          }
        }
      }

      multipleValues[i] = values.join(',');
    }

    return multipleValues.join(',');
  }

  function transition(property, value, style, propertyPrefixMap) {
    // also check for already prefixed transitions
    if (typeof value === 'string' && properties$1.hasOwnProperty(property)) {
      var outputValue = prefixValue$1(value, propertyPrefixMap);
      // if the property is already prefixed
      var webkitOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
        return !/-moz-|-ms-/.test(val);
      }).join(',');

      if (property.indexOf('Webkit') > -1) {
        return webkitOutput;
      }

      var mozOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
        return !/-webkit-|-ms-/.test(val);
      }).join(',');

      if (property.indexOf('Moz') > -1) {
        return mozOutput;
      }

      style['Webkit' + capitalizeString(property)] = webkitOutput;
      style['Moz' + capitalizeString(property)] = mozOutput;
      return outputValue;
    }
  }

  var plugins = [backgroundClip, crossFade, cursor, filter, flexboxOld, gradient, grid, imageSet, logical, position, sizing, transition, flex];

  var prefix = createPrefixer({
    prefixMap: data.prefixMap,
    plugins: plugins
  });

  var unitless = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    // SVG-related properties
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  var shortHandProperties = ['animation', 'background', 'border', 'border-bottom', 'border-left', 'border-radius', 'border-right', 'border-top', 'column-rule', 'columns', 'flex', 'flex-flow', 'font', 'grid', 'grid-area', 'grid-column', 'grid-row', 'grid-template', 'list-style', 'margin', 'offset', 'outline', 'overflow', 'padding', 'place-content', 'place-items', 'place-self', 'text-decoration', 'transition'];
  var i18n = {
    properties: {
      borderTopLeftRadius: 'borderTopRightRadius',
      borderTopRightRadius: 'borderTopLeftRadius',
      borderBottomLeftRadius: 'borderBottomRightRadius',
      borderBottomRightRadius: 'borderBottomLeftRadius',
      borderLeftColor: 'borderRightColor',
      borderLeftStyle: 'borderRightStyle',
      borderLeftWidth: 'borderRightWidth',
      borderRightColor: 'borderLeftColor',
      borderRightStyle: 'borderLeftStyle',
      borderRightWidth: 'borderLeftWidth',
      left: 'right',
      marginLeft: 'marginRight',
      marginRight: 'marginLeft',
      paddingLeft: 'paddingRight',
      paddingRight: 'paddingLeft',
      right: 'left'
    },
    values: {
      ltr: 'rtl',
      rtl: 'ltr',
      left: 'right',
      right: 'left',
      wResize: 'eResize',
      eResize: 'wResize',
      swResize: 'seResize',
      seResize: 'swResize',
      nwResize: 'neResize',
      neResize: 'nwResize'
    }
  };

  // adapted from styletron - https://raw.githubusercontent.com/styletron/styletron/c157e2a3a2592d639ae665342b2c0be8774e916b/packages/styletron-engine-atomic/src/sort-css-media-queries.js
  var minMaxWidth = /(!?\(\s*min(-device-)?-width).+\(\s*max(-device)?-width/i;
  var minWidth = /\(\s*min(-device)?-width/i;
  var maxMinWidth = /(!?\(\s*max(-device)?-width).+\(\s*min(-device)?-width/i;
  var maxWidth = /\(\s*max(-device)?-width/i;

  var isMinWidth = _testQuery(minMaxWidth, maxMinWidth, minWidth);

  var isMaxWidth = _testQuery(maxMinWidth, minMaxWidth, maxWidth);

  var minMaxHeight = /(!?\(\s*min(-device)?-height).+\(\s*max(-device)?-height/i;
  var minHeight = /\(\s*min(-device)?-height/i;
  var maxMinHeight = /(!?\(\s*max(-device)?-height).+\(\s*min(-device)?-height/i;
  var maxHeight = /\(\s*max(-device)?-height/i;

  var isMinHeight = _testQuery(minMaxHeight, maxMinHeight, minHeight);

  var isMaxHeight = _testQuery(maxMinHeight, minMaxHeight, maxHeight);

  var isPrint = /print/i;
  var isPrintOnly = /^print$/i;
  var maxValue = Number.MAX_VALUE;

  function _getQueryLength(length) {
    var matches = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/.exec(length);

    if (matches === null) {
      return maxValue;
    }

    var number = matches[1];
    var unit = matches[2];

    switch (unit) {
      case 'ch':
        number = parseFloat(number) * 8.8984375;
        break;

      case 'em':
      case 'rem':
        number = parseFloat(number) * 16;
        break;

      case 'ex':
        number = parseFloat(number) * 8.296875;
        break;

      case 'px':
        number = parseFloat(number);
        break;
    }

    return +number;
  }

  function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
    return function (query) {
      if (doubleTestTrue.test(query)) {
        return true;
      } else if (doubleTestFalse.test(query)) {
        return false;
      }

      return singleTest.test(query);
    };
  }

  function _testIsPrint(a, b) {
    var isPrintA = isPrint.test(a);
    var isPrintOnlyA = isPrintOnly.test(a);
    var isPrintB = isPrint.test(b);
    var isPrintOnlyB = isPrintOnly.test(b);

    if (isPrintA && isPrintB) {
      if (!isPrintOnlyA && isPrintOnlyB) {
        return 1;
      }

      if (isPrintOnlyA && !isPrintOnlyB) {
        return -1;
      }

      return a.localeCompare(b);
    }

    if (isPrintA) {
      return 1;
    }

    if (isPrintB) {
      return -1;
    }

    return null;
  }

  function sortCSSmq(a, b) {
    if (a === '') {
      return -1;
    }

    if (b === '') {
      return 1;
    }

    var testIsPrint = _testIsPrint(a, b);

    if (testIsPrint !== null) {
      return testIsPrint;
    }

    var minA = isMinWidth(a) || isMinHeight(a);
    var maxA = isMaxWidth(a) || isMaxHeight(a);
    var minB = isMinWidth(b) || isMinHeight(b);
    var maxB = isMaxWidth(b) || isMaxHeight(b);

    if (minA && maxB) {
      return -1;
    }

    if (maxA && minB) {
      return 1;
    }

    var lengthA = _getQueryLength(a);

    var lengthB = _getQueryLength(b);

    if (lengthA === maxValue && lengthB === maxValue) {
      return a.localeCompare(b);
    } else if (lengthA === maxValue) {
      return 1;
    } else if (lengthB === maxValue) {
      return -1;
    }

    if (lengthA > lengthB) {
      if (maxA) {
        return -1;
      }

      return 1;
    }

    if (lengthA < lengthB) {
      if (maxA) {
        return 1;
      }

      return -1;
    }

    return a.localeCompare(b);
  }

  /**
   * This module is a fork of and modifies: https://git.io/fjceH
   *
   * The original source is (c) Nicolas Gallagher
   * and licensed under the MIT license found a thttps://git.io/fjceS
   */

  /**
   * Order-based insertion of CSS.
   *
   * Each rule is associated with a numerically defined group.
   * Groups are ordered within the style sheet according to their number, with the
   * lowest first.
   *
   * Groups are implemented using marker rules. The selector of the first rule of
   * each group is used only to encode the group number for hydration. An
   * alternative implementation could rely on CSSMediaRule, allowing groups to be
   * treated as a sub-sheet, but the Edge implementation of CSSMediaRule is
   * broken.
   * https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule
   * https://gist.github.com/necolas/aa0c37846ad6bd3b05b727b959e82674
   */

  function createOrderedCSSStyleSheet(sheet) {
    var groups = {};
    var selectors = {};
    /**
     * Hydrate approximate record from any existing rules in the sheet.
     */

    if (sheet != null) {
      var group;
      Array.prototype.forEach.call(sheet.cssRules, function (cssRule, i) {
        var cssText = cssRule.cssText; // Create record of existing selectors and rules

        if (cssText.indexOf('style-sheet-group') > -1) {
          group = decodeGroupRule(cssRule);
          groups[group] = {
            start: i,
            rules: [cssText],
            mq: []
          };
        } else {
          var selectorText = getSelectorText(cssText);

          if (selectorText != null) {
            selectors[selectorText.selector] = true;
            var index = groups[group].rules.length - 1;

            if (selectorText.media) {
              index = groups[group].mq.indexOf(selectorText.media);

              if (index === -1) {
                groups[group].mq.push(selectorText.media);
                groups[group].mq.sort(sortCSSmq);
                index = groups[group].mq.indexOf(selectorText.media);
              }
            }

            groups[group].rules.splice(index + 1, 0, cssText);
          }
        }
      });
    }

    function sheetInsert(sheet, group, text, index) {
      var orderedGroups = getOrderedGroups(groups);
      var groupIndex = orderedGroups.indexOf(group);
      var nextGroupIndex = groupIndex + 1;
      var nextGroup = orderedGroups[nextGroupIndex]; // Insert rule before the next group, or at the end of the stylesheet

      var position = nextGroup != null && groups[nextGroup].start != null ? groups[nextGroup].start - _typeof(index) === 'number' ? groups[group].rules.length - index : 0 : sheet.cssRules.length;
      var isInserted = insertRuleAt(sheet, text, position);

      if (isInserted) {
        // Set the starting index of the new group
        if (groups[group].start == null) {
          groups[group].start = position;
        } // Increment the starting index of all subsequent groups


        for (var i = nextGroupIndex; i < orderedGroups.length; i += 1) {
          var groupNumber = orderedGroups[i];
          var previousStart = groups[groupNumber].start;
          groups[groupNumber].start = previousStart + 1;
        }
      }

      return isInserted;
    }

    function getTextContent() {
      return getOrderedGroups(groups).reduce(function (text, group, index) {
        var rules = groups[group].rules;
        return text + (index > 0 ? '\n' : '') + rules.join('\n');
      }, '');
    }

    var OrderedCSSStyleSheet = {
      /**
       * The textContent of the style sheet.
       */
      getTextContent: getTextContent,

      /**
       * Returns the textContent of the style sheet and removes all the rules from it.
       */
      flush: function flush() {
        var textContent = getTextContent();
        groups = {};
        selectors = {};

        if (sheet != null) {
          Array.prototype.forEach.call(sheet.cssRules, function (_, i) {
            sheet.deleteRule(i);
          });
        }

        return textContent;
      },

      /**
       * Insert a rule into the style sheet
       */
      insertRule: function insertRule(cssText, groupValue, index) {
        var group = Number(groupValue);

        if (isNaN(group)) {
          throw new Error("".concat(groupValue, " - Invalid group. Use OrderedCSSStyleSheet.insertRule(cssText, groupId)"));
        } // Create a new group.


        if (groups[group] == null) {
          var markerRule = encodeGroupRule(group); // Create the internal record.

          groups[group] = {
            start: null,
            rules: [markerRule],
            mq: []
          }; // Update CSSOM.

          if (sheet != null) {
            sheetInsert(sheet, group, markerRule);
          }
        } // selectorText is more reliable than cssText for insertion checks. The
        // browser excludes vendor-prefixed properties and rewrites certain values
        // making cssText more likely to be different from what was inserted.


        var selectorText = getSelectorText(cssText);

        if (selectorText != null && selectors[selectorText.selector] == null) {
          selectors[selectorText.selector] = true;

          if (typeof index !== 'number') {
            index = groups[group].rules.length - 1;

            if (selectorText.media) {
              index = groups[group].mq.indexOf(selectorText.media);

              if (index === -1) {
                groups[group].mq.push(selectorText.media);
                groups[group].mq.sort(sortCSSmq);
                index = groups[group].mq.indexOf(selectorText.media);
              }
            }
          }

          if (index > groups[group].rules.length - 1) {
            throw new Error("index ".concat(index, " out of bound for group ").concat(group));
          }

          groups[group].rules.splice(index + 1, 0, cssText); // Update CSSOM.

          if (sheet != null) {
            var isInserted = sheetInsert(sheet, group, cssText, index);

            if (!isInserted) {
              // Revert internal record change if a rule was rejected (e.g.,
              // unrecognized pseudo-selector)
              groups[group].rules.splice(index + 1, 1);
            }
          }
        }
      }
    };
    return OrderedCSSStyleSheet;
  }
  /**
   * Helper functions
   */

  function encodeGroupRule(group) {
    return "[style-sheet-group=\"".concat(group, "\"]{}");
  }

  function decodeGroupRule(cssRule) {
    return Number(cssRule.selectorText.split(/["']/)[1]);
  }

  function getOrderedGroups(obj) {
    return Object.keys(obj).map(Number).sort(function (a, b) {
      return a > b ? 1 : -1;
    });
  }

  var pattern = /\s*([,])\s*/g;

  function getSelectorText(cssText) {
    var split = cssText.split('{');
    var selector = split[0].trim();
    var media = null;

    if (selector.startsWith('@media')) {
      media = selector.substring(6).trim();
      selector = split[1].trim();
    }

    return selector !== '' ? {
      media: media,
      selector: selector.replace(pattern, '$1')
    } : null;
  }

  function insertRuleAt(root, cssText, position) {
    try {
      root.insertRule(cssText, position);
      return true;
    } catch (e) {
      // JSDOM doesn't support `CSSSMediaRule#insertRule`.
      // Also ignore errors that occur from attempting to insert vendor-prefixed selectors.
      return false;
    }
  }

  var STYLE_GROUPS = ['classic', 'mediaClassic', 'shorthand', 'mediaShorthand', 'shorthandCombinator', 'mediaShorthandCombinator', 'i18nShorthand', 'mediaI18nShorthand', 'i18nShorthandCombinator', 'mediaI18nShorthandCombinator', 'atomic', 'mediaAtomic', 'atomicCombinator', 'mediaAtomicCombinator'].reduce(function (groups, name, index) {
    groups[name] = index;
    return groups;
  }, {});

  function createClassName(property, value, descendants, media) {
    var ruleType = getRuleType(property, media, descendants);
    return "dss".concat(ruleType, "_").concat(fnv1a(property + descendants + media).toString(36), "-").concat(fnv1a(String(value)).toString(36));
  }

  var hyphenate = function hyphenate(s) {
    return s.replace(/[A-Z]|^ms/g, '-$&').toLowerCase();
  };

  var strigifyDeclaration = function strigifyDeclaration(dec) {
    var stringified = '';

    for (var prop in dec) {
      var value = dec[prop];

      if (Array.isArray(value)) {
        for (var i = 0; i < value.length; i++) {
          stringified += hyphenate(prop) + ':' + value[i] + ';';
        }
      } else {
        stringified += hyphenate(prop) + ':' + value + ';';
      }
    }

    return stringified;
  };

  function createRule(className, declaration, descendants, media) {
    var cls = '.' + className.replace('.', '\\.');
    var selector = descendants ? descendants.replace(/^&/, cls).replace(/&/g, cls) : cls;
    var rule = selector + '{' + strigifyDeclaration(declaration) + '}';
    if (!media) return rule;
    return media + '{' + rule + '}';
  }
  var order = {
    pseudo: ['link', 'visited', 'hover', 'focus-within', 'focus-visible', 'focus', 'active']
  };

  function getRuleType(prop, media, descendants) {
    var name = '';

    if (shortHandProperties.indexOf(prop) > -1) {
      name = media ? 'mediaShorthand' : 'shorthand';
    } else {
      name = media ? 'mediaAtomic' : 'atomic';
    }

    var subGroup = 0;

    if (descendants) {
      var subGroupPart; // is a combinator selector eg :hover > &

      if (descendants.substr(0, 2) !== '&:') {
        name += 'Combinator';
        subGroupPart = descendants.slice(1).split(/\s*[+>~]\s*/g)[0];
      } else {
        subGroupPart = descendants.slice(2);
      }

      var index = order.pseudo.indexOf(subGroupPart.split(':').slice(-1)[0]);

      if (index > -1) {
        subGroup = index + 1;
      }
    }

    return subGroup > 0 ? STYLE_GROUPS[name] + '.' + subGroup : STYLE_GROUPS[name];
  }

  function normalizeValue(value) {
    if (typeof value === 'number') {
      if (value !== 0) {
        return value + 'px';
      }
    } else if (Array.isArray(value)) {
      return value.map(function (v) {
        if (typeof v === 'number' && v !== 0) {
          return v + 'px';
        }

        return v;
      });
    }

    return value;
  }

  function toI18n(lookup, thing) {
    return Object.prototype.hasOwnProperty.call(lookup, thing) ? lookup[thing] : null;
  }

  var cache$1 = {};

  var parse = function parse(obj, descendants, media, opts) {
    var rules = {};

    for (var key in obj) {
      var value = obj[key];
      if (value === null || value === undefined) continue;

      switch (Object.prototype.toString.call(value)) {
        case '[object Object]':
          {
            var parsed = key.charAt(0) === '@' ? parse(value, descendants, key, opts) : parse(value, descendants + key, media, opts);
            Object.assign(rules, parsed);
            break;
          }

        default:
          {
            var cacheKey = key + value + descendants + media;
            var cached = cache$1[cacheKey];

            if (cached) {
              Object.assign(rules, cached);
              break;
            }

            var className = createClassName(key, value, descendants, media);

            if (rules[className]) {
              break;
            }

            if (!unitless[key]) {
              value = normalizeValue(value);
            }

            var declaration = prefix(_defineProperty({}, key, value));
            var rule = createRule(className, declaration, descendants, media);

            if (opts.i18n) {
              var originalProp = key;
              var originalValue = value;
              key = toI18n(i18n.properties, originalProp);
              value = toI18n(i18n.values, originalValue);

              if (key !== null || value !== null) {
                key = key || originalProp;
                value = value || originalValue;
                var i18nClassName = createClassName(key, value, descendants, media); // i18n classNames contain both the ltr and rtl version
                // this is resolved at runtime by the StyleResolver

                className = "".concat(className, "|").concat(i18nClassName);

                var _declaration = prefix(_defineProperty({}, key, value)); // i18n rule is an array with two rules the ltr and the rtl one
                // eg. ['.left { margin-left: 10px }', '.right { margin-right: 10px }']
                // At runtime the StyleResolver will pick the correct one.


                rule = [rule, createRule(i18nClassName, _declaration, descendants, media)];
              }
            }

            rules[className] = rule;
            cache$1[cacheKey] = _defineProperty({}, className, rule);
            break;
          }
      }
    }

    return rules;
  };

  var compile = (function (obj, opts) {
    if (!obj) {
      throw new Error('DSS parser invoked without a mandatory styles object.');
    }

    return parse(obj, '', '', opts);
  });

  function error(message) {
    throw new Error("style-sheet: ".concat(message));
  }

  function validate(obj) {
    for (var k in obj) {
      var key = k.trim();
      var value = obj[key];
      if (value === null) continue;
      var isDeclaration = Object.prototype.toString.call(value) !== '[object Object]';
      validateStr(key, isDeclaration);

      if (!isDeclaration) {
        validate(value);
      } else if (typeof value === 'string' && /!\s*important/.test(value)) {
        error('!important is not allowed');
      }
    }
  }
  function validateStr(key, isDeclaration) {
    if (isDeclaration) {
      return;
    }

    if (key.charAt(0) === '@') {
      return;
    } // Selector


    if (key.split(',').length > 1) {
      error("Invalid nested selector: '".concat(key, "'. Selectors cannot be grouped."));
    }

    if (/::?(after|before|first-letter|first-line)/.test(key)) {
      error("Detected pseudo-element: '".concat(key, "'. Pseudo-elements are not supported. Please use regular elements."));
    }

    if (/:(matches|has|not|lang|any|current)/.test(key)) {
      error("Detected unsupported pseudo-class: '".concat(key, "'."));
    }

    var split = key.split(/\s*[+>~]\s*/g);

    switch (split.length) {
      case 2:
        if (split[0].charAt(0) !== ':') {
          error("Invalid nested selector: '".concat(key, "'. ") + 'The left part of a combinator selector must be a pseudo-class eg. `:hover`.');
        }

        if (split[1] !== '&') {
          error("Invalid nested selector: '".concat(key, "'. ") + 'The right part of a combinator selector must be `&`.');
        }

        break;

      case 1:
        if (split[0].indexOf(' ') > -1) {
          error("Invalid nested selector: ".concat(key, ". Complex selectors are not supported."));
        }

        if (split[0].charAt(0) !== '&') {
          error("Invalid nested selector: '".concat(key, "'. ") + 'A pseudo-class selector should reference its parent with `&` eg. `&:hover {}`.');
        }

        break;

      default:
        error("Invalid nested selector: ".concat(key, "."));
    }

    if (/\[/.test(key)) {
      error("Invalid selector: ".concat(key, ". Cannot use attribute selectors, please use only class selectors."));
    }
  }

  var stackframe = createCommonjsModule(function (module, exports) {
  (function(root, factory) {
      // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

      /* istanbul ignore next */
      {
          module.exports = factory();
      }
  }(commonjsGlobal, function() {
      function _isNumber(n) {
          return !isNaN(parseFloat(n)) && isFinite(n);
      }

      function _capitalize(str) {
          return str.charAt(0).toUpperCase() + str.substring(1);
      }

      function _getter(p) {
          return function() {
              return this[p];
          };
      }

      var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
      var numericProps = ['columnNumber', 'lineNumber'];
      var stringProps = ['fileName', 'functionName', 'source'];
      var arrayProps = ['args'];

      var props = booleanProps.concat(numericProps, stringProps, arrayProps);

      function StackFrame(obj) {
          if (obj instanceof Object) {
              for (var i = 0; i < props.length; i++) {
                  if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {
                      this['set' + _capitalize(props[i])](obj[props[i]]);
                  }
              }
          }
      }

      StackFrame.prototype = {
          getArgs: function() {
              return this.args;
          },
          setArgs: function(v) {
              if (Object.prototype.toString.call(v) !== '[object Array]') {
                  throw new TypeError('Args must be an Array');
              }
              this.args = v;
          },

          getEvalOrigin: function() {
              return this.evalOrigin;
          },
          setEvalOrigin: function(v) {
              if (v instanceof StackFrame) {
                  this.evalOrigin = v;
              } else if (v instanceof Object) {
                  this.evalOrigin = new StackFrame(v);
              } else {
                  throw new TypeError('Eval Origin must be an Object or StackFrame');
              }
          },

          toString: function() {
              var fileName = this.getFileName() || '';
              var lineNumber = this.getLineNumber() || '';
              var columnNumber = this.getColumnNumber() || '';
              var functionName = this.getFunctionName() || '';
              if (this.getIsEval()) {
                  if (fileName) {
                      return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
                  }
                  return '[eval]:' + lineNumber + ':' + columnNumber;
              }
              if (functionName) {
                  return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
              }
              return fileName + ':' + lineNumber + ':' + columnNumber;
          }
      };

      StackFrame.fromString = function StackFrame$$fromString(str) {
          var argsStartIndex = str.indexOf('(');
          var argsEndIndex = str.lastIndexOf(')');

          var functionName = str.substring(0, argsStartIndex);
          var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
          var locationString = str.substring(argsEndIndex + 1);

          if (locationString.indexOf('@') === 0) {
              var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
              var fileName = parts[1];
              var lineNumber = parts[2];
              var columnNumber = parts[3];
          }

          return new StackFrame({
              functionName: functionName,
              args: args || undefined,
              fileName: fileName,
              lineNumber: lineNumber || undefined,
              columnNumber: columnNumber || undefined
          });
      };

      for (var i = 0; i < booleanProps.length; i++) {
          StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
          StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
              return function(v) {
                  this[p] = Boolean(v);
              };
          })(booleanProps[i]);
      }

      for (var j = 0; j < numericProps.length; j++) {
          StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
          StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
              return function(v) {
                  if (!_isNumber(v)) {
                      throw new TypeError(p + ' must be a Number');
                  }
                  this[p] = Number(v);
              };
          })(numericProps[j]);
      }

      for (var k = 0; k < stringProps.length; k++) {
          StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
          StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
              return function(v) {
                  this[p] = String(v);
              };
          })(stringProps[k]);
      }

      return StackFrame;
  }));
  });

  var errorStackParser = createCommonjsModule(function (module, exports) {
  (function(root, factory) {
      // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

      /* istanbul ignore next */
      {
          module.exports = factory(stackframe);
      }
  }(commonjsGlobal, function ErrorStackParser(StackFrame) {

      var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
      var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
      var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;

      return {
          /**
           * Given an Error object, extract the most information from it.
           *
           * @param {Error} error object
           * @return {Array} of StackFrames
           */
          parse: function ErrorStackParser$$parse(error) {
              if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                  return this.parseOpera(error);
              } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                  return this.parseV8OrIE(error);
              } else if (error.stack) {
                  return this.parseFFOrSafari(error);
              } else {
                  throw new Error('Cannot parse given Error object');
              }
          },

          // Separate line and column numbers from a string of the form: (URI:Line:Column)
          extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
              // Fail-fast but return locations like "(native)"
              if (urlLike.indexOf(':') === -1) {
                  return [urlLike];
              }

              var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
              var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ''));
              return [parts[1], parts[2] || undefined, parts[3] || undefined];
          },

          parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
              var filtered = error.stack.split('\n').filter(function(line) {
                  return !!line.match(CHROME_IE_STACK_REGEXP);
              }, this);

              return filtered.map(function(line) {
                  if (line.indexOf('(eval ') > -1) {
                      // Throw away eval information until we implement stacktrace.js/stackframe#8
                      line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, '');
                  }
                  var sanitizedLine = line.replace(/^\s+/, '').replace(/\(eval code/g, '(');

                  // capture and preseve the parenthesized location "(/foo/my bar.js:12:87)" in
                  // case it has spaces in it, as the string is split on \s+ later on
                  var location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/);

                  // remove the parenthesized location from the line, if it was matched
                  sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;

                  var tokens = sanitizedLine.split(/\s+/).slice(1);
                  // if a location was matched, pass it to extractLocation() otherwise pop the last token
                  var locationParts = this.extractLocation(location ? location[1] : tokens.pop());
                  var functionName = tokens.join(' ') || undefined;
                  var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

                  return new StackFrame({
                      functionName: functionName,
                      fileName: fileName,
                      lineNumber: locationParts[1],
                      columnNumber: locationParts[2],
                      source: line
                  });
              }, this);
          },

          parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
              var filtered = error.stack.split('\n').filter(function(line) {
                  return !line.match(SAFARI_NATIVE_CODE_REGEXP);
              }, this);

              return filtered.map(function(line) {
                  // Throw away eval information until we implement stacktrace.js/stackframe#8
                  if (line.indexOf(' > eval') > -1) {
                      line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ':$1');
                  }

                  if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                      // Safari eval frames only have function names and nothing else
                      return new StackFrame({
                          functionName: line
                      });
                  } else {
                      var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
                      var matches = line.match(functionNameRegex);
                      var functionName = matches && matches[1] ? matches[1] : undefined;
                      var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));

                      return new StackFrame({
                          functionName: functionName,
                          fileName: locationParts[0],
                          lineNumber: locationParts[1],
                          columnNumber: locationParts[2],
                          source: line
                      });
                  }
              }, this);
          },

          parseOpera: function ErrorStackParser$$parseOpera(e) {
              if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                  e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                  return this.parseOpera9(e);
              } else if (!e.stack) {
                  return this.parseOpera10(e);
              } else {
                  return this.parseOpera11(e);
              }
          },

          parseOpera9: function ErrorStackParser$$parseOpera9(e) {
              var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
              var lines = e.message.split('\n');
              var result = [];

              for (var i = 2, len = lines.length; i < len; i += 2) {
                  var match = lineRE.exec(lines[i]);
                  if (match) {
                      result.push(new StackFrame({
                          fileName: match[2],
                          lineNumber: match[1],
                          source: lines[i]
                      }));
                  }
              }

              return result;
          },

          parseOpera10: function ErrorStackParser$$parseOpera10(e) {
              var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
              var lines = e.stacktrace.split('\n');
              var result = [];

              for (var i = 0, len = lines.length; i < len; i += 2) {
                  var match = lineRE.exec(lines[i]);
                  if (match) {
                      result.push(
                          new StackFrame({
                              functionName: match[3] || undefined,
                              fileName: match[2],
                              lineNumber: match[1],
                              source: lines[i]
                          })
                      );
                  }
              }

              return result;
          },

          // Opera 10.65+ Error.stack very similar to FF/Safari
          parseOpera11: function ErrorStackParser$$parseOpera11(error) {
              var filtered = error.stack.split('\n').filter(function(line) {
                  return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
              }, this);

              return filtered.map(function(line) {
                  var tokens = line.split('@');
                  var locationParts = this.extractLocation(tokens.pop());
                  var functionCall = (tokens.shift() || '');
                  var functionName = functionCall
                          .replace(/<anonymous function(: (\w+))?>/, '$2')
                          .replace(/\([^\)]*\)/g, '') || undefined;
                  var argsRaw;
                  if (functionCall.match(/\(([^\)]*)\)/)) {
                      argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, '$1');
                  }
                  var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                      undefined : argsRaw.split(',');

                  return new StackFrame({
                      functionName: functionName,
                      args: args,
                      fileName: locationParts[0],
                      lineNumber: locationParts[1],
                      columnNumber: locationParts[2],
                      source: line
                  });
              }, this);
          }
      };
  }));
  });

  /* global Blob, Worker, URL, module */
  function createSourceMapsEngine() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$baseUrl = _ref.baseUrl,
        baseUrl = _ref$baseUrl === void 0 ? 'https://unpkg.com/css-to-js-sourcemap-worker@2.0.5' : _ref$baseUrl,
        _ref$renderInterval = _ref.renderInterval,
        renderInterval = _ref$renderInterval === void 0 ? 120 : _ref$renderInterval;

    var workerBlob = new Blob(["importScripts(\"".concat(baseUrl, "/worker.js\")")], {
      type: 'application/javascript'
    });
    var worker = new Worker(URL.createObjectURL(workerBlob));
    worker.postMessage({
      id: 'init_wasm',
      url: "".concat(baseUrl, "/mappings.wasm")
    });
    var style = document.createElement('style');
    document.head.appendChild(style);
    worker.postMessage({
      id: 'set_render_interval',
      interval: renderInterval
    });

    if (module && module.hot) {
      module.hot.addStatusHandler(function (status) {
        if (status === 'dispose') {
          worker.postMessage({
            id: 'invalidate'
          });
        }
      });
    }

    worker.onmessage = function (msg) {
      var _msg$data = msg.data,
          id = _msg$data.id,
          css = _msg$data.css;

      if (id === 'render_css' && css) {
        style.appendChild(document.createTextNode(css));
      }
    };

    var counter = 0;
    return {
      create: function create() {
        var className = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "__debug";
        var stackIndex = 3;
        var error = new Error('stacktrace source');
        var prefix = getDebugClassName(error, stackIndex);
        var cls = typeof className === 'function' ? className(prefix, counter) : className + '-' + counter;
        counter++;
        worker.postMessage({
          id: 'add_mapped_class',
          className: cls,
          stackInfo: {
            stack: error.stack,
            message: error.message
          },
          stackIndex: stackIndex
        });
        return cls;
      }
    };
  }
  function getDebugClassName(error) {
    var stackIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var line = errorStackParser.parse(error)[stackIndex];

    if (!line || !line.fileName) {
      return '__dss-debug';
    }

    var parts = line.fileName.split('/');
    var name = parts.pop().replace(/\..*$/, '');

    if (name === 'index') {
      name = parts.pop();
    }

    name = name.replace(/\W/g, '-');
    return name.charAt(0).toUpperCase() + name.slice(1);
  }

  var isBrowser = typeof window !== 'undefined';
  var isProd = "development" === 'production';

  function createStyleSheet(rules, opts) {
    var cache = typeof Map === 'undefined' ? null : new Map();
    var sourceMapsEngine;

    if ( !isBrowser && typeof Worker !== 'undefined') {
      sourceMapsEngine = createSourceMapsEngine();
    }

    return {
      create: function create(styles) {
        if (cache) {
          var cached = cache.get(styles);

          if (cached) {
            return cached;
          }
        }

        var locals = {};

        var _loop = function _loop(token) {
          var rule = styles[token];

          {
            validate(rule);
          }

          var compiled = compile(rule, opts);
          Object.assign(rules, compiled);
          locals[token] = Object.keys(compiled); // In dev add source maps

          if ( sourceMapsEngine) {
            locals[token].unshift(sourceMapsEngine.create(function (prefix, id) {
              return opts.sourceMaps.className({
                prefix: prefix,
                key: token,
                id: id
              });
            }));
          }
        };

        for (var token in styles) {
          _loop(token);
        }

        if (cache) {
          cache.set(styles, locals);
        }

        return locals;
      }
    };
  }

  function concatClassName(dest, className) {
    if (className.substr(0, 3) !== 'dss') {
      return {
        shouldInject: false,
        className: "".concat(className, " ").concat(dest),
        group: null
      };
    }

    var property = className.substr(0, className.indexOf('-'));

    if (dest.indexOf(property) > -1) {
      return {
        shouldInject: false,
        className: dest,
        group: null
      };
    }

    return {
      shouldInject: true,
      className: "".concat(dest, " ").concat(className),
      group: Number(className.substring(3, className.indexOf('_')).replace('\\', ''))
    };
  }

  function createStyleResolver(sheet, rules, opts) {
    var resolved = {};
    var injected = {};
    return {
      getStyleSheet: function getStyleSheet() {
        // On the server we reset the caches.
        if (typeof window === 'undefined') {
          resolved = {};
          injected = {};
        }

        return sheet;
      },
      resolve: function resolve(style) {
        var i18n = opts.i18n || {};
        var stylesToString = i18n.isRTL + i18n.doLeftAndRightSwapInRTL + style.join();

        if (resolved[stylesToString]) {
          return resolved[stylesToString];
        }

        var resolvedClassName = '';

        for (var i = style.length - 1; i >= 0; i--) {
          var current = style[i];

          if (!current) {
            continue;
          }

          if (typeof current === 'string') {
            current = [current];
          }

          for (var j = 0; j < current.length; j++) {
            var className = current[j];
            var rule = void 0; // resolve i18n rules

            var i18nClassNames = className.split('|');
            var i18nRules = void 0;
            var i18nIndex = void 0;

            if (i18nClassNames.length > 1) {
              if (i18n.isRTL && i18n.doLeftAndRightSwapInRTL) {
                i18nIndex = 1;
              } else {
                i18nIndex = 0;
              }

              i18nRules = rules[className];
              className = i18nClassNames[i18nIndex];
              rule = i18nRules[i18nIndex];
            } else {
              rule = rules[className];
            }

            var result = concatClassName(resolvedClassName, className);
            resolvedClassName = result.className;

            if (result.shouldInject && !injected[className]) {
              if (rule) {
                sheet.insertRule(rule, result.group);

                if (i18nRules && !isBrowser) {
                  var i18nIndexInverse = i18nIndex ? 0 : 1;
                  sheet.insertRule(i18nRules[i18nIndexInverse], result.group);
                  injected[i18nClassNames[i18nIndexInverse]] = true;
                }
              }

              injected[className] = true;
            }
          }
        }

        resolvedClassName = resolvedClassName.trim();
        resolved[stylesToString] = resolvedClassName;
        return resolvedClassName;
      }
    };
  }

  function createSheet(document) {
    document = document || typeof window === 'undefined' ? null : window.document;
    var sheet = null;

    if (document) {
      var style = document.createElement('style');
      document.head.appendChild(style);
      sheet = style.sheet;
    }

    return sheet;
  }
  function create() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var i18n;

    function setI18nManager(manager) {
      i18n = manager;

      if (i18n && !isProd) {
        if (typeof i18n.isRTL !== 'boolean') {
          throw new Error('i18n.isRTL must be a boolean.');
        }

        if (typeof i18n.doLeftAndRightSwapInRTL !== 'boolean') {
          throw new Error('i18n.doLeftAndRightSwapInRTL must be a boolean.');
        }
      }
    }

    setI18nManager(options.i18n);
    var sheet = createOrderedCSSStyleSheet(options.sheet || createSheet());
    var rules = {};
    var opts = {
      get i18n() {
        return i18n;
      }

    };

    {
      opts.sourceMaps = Object.assign({
        className: function className(_ref) {
          var prefix = _ref.prefix,
              key = _ref.key,
              id = _ref.id;
          return "".concat(prefix, "__").concat(key, "-").concat(id);
        }
      }, options.sourceMaps || {});
    }

    return {
      StyleSheet: createStyleSheet(rules, opts),
      StyleResolver: createStyleResolver(sheet, rules, opts),
      setI18nManager: setI18nManager
    };
  }

  exports.create = create;
  exports.createSheet = createSheet;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
